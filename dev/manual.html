<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · SGFHE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SGFHE.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="manual.html">Manual</a><ul class="internal"><li><a class="tocitem" href="#Data-flow-1"><span>Data flow</span></a></li><li><a class="tocitem" href="#Private-key-encrpytion-1"><span>Private key encrpytion</span></a></li><li><a class="tocitem" href="#Public-key-encrpytion-1"><span>Public key encrpytion</span></a></li><li><a class="tocitem" href="#Bootstrap-manual-1"><span>Bootstrap</span></a></li><li><a class="tocitem" href="#Packing-encrypted-bits-1"><span>Packing encrypted bits</span></a></li></ul></li><li><a class="tocitem" href="api.html">API reference</a></li><li><a class="tocitem" href="theory.html">Theory</a></li><li><a class="tocitem" href="history.html">Version history</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="manual.html">Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="manual.html">Manual</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nucypher/SGFHE.jl/blob/master/docs/src/manual.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual-1"><a class="docs-heading-anchor" href="#Manual-1">Manual</a><a class="docs-heading-anchor-permalink" href="#Manual-1" title="Permalink"></a></h1><h2 id="Data-flow-1"><a class="docs-heading-anchor" href="#Data-flow-1">Data flow</a><a class="docs-heading-anchor-permalink" href="#Data-flow-1" title="Permalink"></a></h2><p>The FHE scheme operates with several different representations of ciphertexts, each having its advantages and disadvantages. The scheme below shows the possible transformations between them and can be used as a quick reference.</p><p><img src="sgfhe.svg" alt/></p><p>In the examples in this section we will assume that the following modules are imported:</p><pre><code class="language-julia">using Random
using SGFHE</code></pre><h2 id="Private-key-encrpytion-1"><a class="docs-heading-anchor" href="#Private-key-encrpytion-1">Private key encrpytion</a><a class="docs-heading-anchor-permalink" href="#Private-key-encrpytion-1" title="Permalink"></a></h2><p>We will start with generating a private key use it to encrypt and then decrypt some data. Data can only be encrypted in blocks of size <code>n</code>, which is the polynomial length passed to the <a href="api.html#SGFHE.Params"><code>Params</code></a> constructor.</p><p>The simplest variant is to encrypt a single bit:</p><pre><code class="language-julia">rng = MersenneTwister()
params = Params(64)
key = PrivateKey(params, rng)

bits = rand(Bool, params.n)
encrypted_array = encrypt(key, rng, bits)
decrypted_bits = decrypt(key, encrypted_array)

@assert bits == decrypted_bits

# output
</code></pre><p>Here we used 64 as the polynomial length in the FHE scheme. The polynomial length must be a power of 2 greater than 64, and the larger it is, the more secure the encryption is (and, naturally, the slower it is, too).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We need to create an RNG and pass it to some functions explicitly. All functions that in some way use randomness take an RNG as a parameter, and it is the user&#39;s responsibility to assure that it is cryptographically secure (the default Julia one, <code>MersenneTwister</code>, isn&#39;t, and is only used here for demonstration purposes).</p></div></div><p>The resulting ciphertext has the expansion coefficient of <code>2t</code>, where <code>t</code> is the bit size of the integer type used (which is chosen to be able to fit numbers up to <code>16n</code>, where <code>n</code> is the polynomial length, see <a href="theory.html#Space-optimal-representation-private-1">the corresponding theory section</a> for details).</p><p>There is a more efficient representation possible, with the expansion coefficient of only 6. It cannot be decrypted directly, and must be normalized first:</p><pre><code class="language-julia">rng = MersenneTwister()
params = Params(64)
key = PrivateKey(params, rng)

bits = rand(Bool, params.n)
encrypted_array = encrypt_optimal(key, rng, bits)
decrypted_bits = decrypt(key, normalize_ciphertext(encrypted_array))

@assert bits == decrypted_bits

# output
</code></pre><h2 id="Public-key-encrpytion-1"><a class="docs-heading-anchor" href="#Public-key-encrpytion-1">Public key encrpytion</a><a class="docs-heading-anchor-permalink" href="#Public-key-encrpytion-1" title="Permalink"></a></h2><p>The FHE scheme supports asymmetric encryption. We can generate a public key out of our private key, and distribute it. Anyone can use it to encrpyt data, which can be decrypted only by someone possessing the private key.</p><p>At the moment one can only use a public key to encrypt arrays of bits:</p><pre><code class="language-julia">rng = MersenneTwister()
params = Params(64)
key = PrivateKey(params, rng)
pkey = PublicKey(rng, key)

bits = rand(Bool, params.n)
encrypted_bits = encrypt(pkey, rng, bits)
decrypted_bits = decrypt(key, encrypted_bits)

@assert bits == decrypted_bits

# output
</code></pre><p>Similarly to the private key encrpytion, one can use an intermediate space-efficient representation, although the ciphertext expansion coefficient is larger than that for the private key (namely, <code>10 + log2(n)</code>):</p><pre><code class="language-julia">rng = MersenneTwister()
params = Params(64)
key = PrivateKey(params, rng)
pkey = PublicKey(rng, key)

bits = rand(Bool, params.n)
encrypted_array = encrypt_optimal(pkey, rng, bits)
decrypted_bits = decrypt(key, normalize_ciphertext(encrypted_array))

@assert bits == decrypted_bits

# output
</code></pre><h2 id="Bootstrap-manual-1"><a class="docs-heading-anchor" href="#Bootstrap-manual-1">Bootstrap</a><a class="docs-heading-anchor-permalink" href="#Bootstrap-manual-1" title="Permalink"></a></h2><p>The main feature of FHE is being able to perform arbitrary operations on the encrypted data. In the scheme that this package implements, one can take two encrypted bits and obtain ciphertexts encrypting the result of applying <code>AND</code>, <code>OR</code> and <code>XOR</code> operations on the corresponding plaintext bits. This is enough to implement any logical circuit.</p><p>Since after the encryption all we have is an encrypted block of bits, it has to be split into single <a href="api.html#SGFHE.EncryptedBit"><code>EncryptedBit</code></a> objects first using the function <a href="api.html#SGFHE.split_ciphertext"><code>split_ciphertext</code></a>. This leads to a significant ciphertext expansion (of the order of kilobytes of data to represent a single bit, depending on the polynomial length). That&#39;s why after running the circuit on separate bits it is a good idea to pack them back with <a href="api.html#SGFHE.pack_encrypted_bits"><code>pack_encrypted_bits</code></a> (more on this later).</p><p>Bootstrapping procedure requires a special bootstrap key, which can be generated from the private key:</p><pre><code class="language-julia">rng = MersenneTwister()
params = Params(64)
key = PrivateKey(params, rng)
bkey = BootstrapKey(rng, key)

bits = rand(Bool, params.n)
encrypted_array = encrypt(key, rng, bits)
encrypted_bits = split_ciphertext(encrypted_array)

# we will run bootstrap() on the 10th and the 20th bit
i1 = 10
i2 = 20

y1 = bits[i1]
y2 = bits[i2]

enc_y1 = encrypted_bits[i1]
enc_y2 = encrypted_bits[i2]

enc_and, enc_or, enc_xor = bootstrap(bkey, rng, enc_y1, enc_y2)
res_and, res_or, res_xor = [decrypt(key, enc_bit) for enc_bit in (enc_and, enc_or, enc_xor)]

@assert res_and == y1 &amp; y2
@assert res_or == y1 | y2
@assert res_xor == xor(y1, y2)

# output
</code></pre><p>If one passes <code>nothing</code> instead of an RNG, bootstrap will be run deterministically, producing the same encrypted bits each time, which may be beneficial for some applications:</p><pre><code class="language-julia">enc1_and, enc1_or, enc1_xor = bootstrap(bkey, nothing, enc_y1, enc_y2)
enc2_and, enc2_or, enc2_xor = bootstrap(bkey, nothing, enc_y1, enc_y2)

@assert enc1_and == enc2_and
@assert enc1_or == enc2_or
@assert enc1_xor == enc2_xor

res_and, res_or, res_xor = [decrypt(key, enc_bit) for enc_bit in (enc1_and, enc1_or, enc1_xor)]

@assert res_and == y1 &amp; y2
@assert res_or == y1 | y2
@assert res_xor == xor(y1, y2)

# output
</code></pre><h2 id="Packing-encrypted-bits-1"><a class="docs-heading-anchor" href="#Packing-encrypted-bits-1">Packing encrypted bits</a><a class="docs-heading-anchor-permalink" href="#Packing-encrypted-bits-1" title="Permalink"></a></h2><p>After you finished with your bootstrapped circuit, you are left with a bunch of encrypted bit objects. They are not very efficient in terms of occupied space, so any <code>n</code> (the scheme&#39;s polynomial length) encrypted bits can be packed back into an encrypted array. As opposed to an encrypted array created by <a href="api.html#SGFHE.encrypt"><code>encrypt</code></a>, the ciphertext expansion coefficient is 8 times larger (<code>16t</code> instead of <code>2t</code>, where <code>t</code> is the bit size of the interger type used), but it is still much better than the coefficient of a separate encrypted bit.</p><p>The packing function uses the bootstrap key:</p><pre><code class="language-julia">rng = MersenneTwister()
params = Params(64)
key = PrivateKey(params, rng)
bkey = BootstrapKey(rng, key)

bits = rand(Bool, params.n)
encrypted_array = encrypt(key, rng, bits)
encrypted_bits = split_ciphertext(encrypted_array)

new_encrypted_array = pack_encrypted_bits(bkey, rng, encrypted_bits)
decrypted_bits = decrypt(key, new_encrypted_array)

@assert bits == decrypted_bits

# output
</code></pre><p>Similarly to the <a href="api.html#SGFHE.bootstrap"><code>bootstrap</code></a>, if one passes <code>nothing</code> as an RNG to <a href="api.html#SGFHE.pack_encrypted_bits"><code>pack_encrypted_bits</code></a>, the result will be deterministic.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="api.html">API reference »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 20 December 2019 18:40">Friday 20 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
