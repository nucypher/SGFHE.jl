var documenterSearchIndex = {"docs":
[{"location":"api.html#API-reference-1","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api.html#Public-API-1","page":"API reference","title":"Public API","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"CurrentModule = SGFHE","category":"page"},{"location":"api.html#Scheme-parameters-1","page":"API reference","title":"Scheme parameters","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"Params","category":"page"},{"location":"api.html#SGFHE.Params","page":"API reference","title":"SGFHE.Params","text":"FHE scheme parameters.\n\nFields\n\nn :: Int - polynomial length.\n\nParams(n::Int; rlwe_type=nothing, mod_repr=nothing)\n\nn: polynomial length. Must be a power of 2, >=64.\n\nrlwe_type: an unsigned integer type used for bootstrapping              (UInt or MLUInt of a large enough size).\n\nmod_repr: the modulo integer representation, must be one of            DarkIntegers.ModUInt, DarkIntegers.MgModUInt\n\n\n\n\n\n","category":"type"},{"location":"api.html#Key-generation-1","page":"API reference","title":"Key generation","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"PrivateKey\nPublicKey\nBootstrapKey","category":"page"},{"location":"api.html#SGFHE.PrivateKey","page":"API reference","title":"SGFHE.PrivateKey","text":"PrivateKey(params::Params, rng::AbstractRNG)\n\nCreates the FHE private key for the FHE parameters.\n\n\n\n\n\n","category":"type"},{"location":"api.html#SGFHE.PublicKey","page":"API reference","title":"SGFHE.PublicKey","text":"PublicKey(rng::AbstractRNG, sk::PrivateKey)\n\nCreates the FHE public key based on the given private key.\n\n\n\n\n\n","category":"type"},{"location":"api.html#SGFHE.BootstrapKey","page":"API reference","title":"SGFHE.BootstrapKey","text":"BootstrapKey(rng::AbstractRNG, sk::PrivateKey)\n\nCreates the FHE bootstrap key based on the given private key.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Encryption-1","page":"API reference","title":"Encryption","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"encrypt\nencrypt_optimal","category":"page"},{"location":"api.html#SGFHE.encrypt","page":"API reference","title":"SGFHE.encrypt","text":"encrypt(key::PrivateKey, rng::AbstractRNG, message::AbstractArray{Bool, 1})\n\nEncrypts a message with the private key. The message must have length equal to the polynomial length n (see Params.n). Returns a PackedCiphertext object.\n\n\n\n\n\nencrypt(key::PublicKey, rng::AbstractRNG, message::AbstractArray{Bool, 1})\n\nEncrypts a message with the public key. The message must have length equal to the polynomial length n (see Params.n). Returns a PackedCiphertext object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.encrypt_optimal","page":"API reference","title":"SGFHE.encrypt_optimal","text":"encrypt_optimal(key::PrivateKey, rng::AbstractRNG, message::AbstractArray{Bool, 1})\n\nEncrypts a message with the private key producing a space-optimal representation (6 bits per bit of the message). The message must have length equal to the polynomial length n (see Params.n). Returns a PrivateEncryptedCiphertext object.\n\n\n\n\n\nencrypt_optimal(key::PublicKey, rng::AbstractRNG, message::AbstractArray{Bool, 1})\n\nEncrypts a message with the public key producing a space-optimal representation (6 bits per bit of the message). The message must have length equal to the polynomial length n (see Params.n). Returns a PublicEncryptedCiphertext object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Decryption-1","page":"API reference","title":"Decryption","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"decrypt","category":"page"},{"location":"api.html#SGFHE.decrypt","page":"API reference","title":"SGFHE.decrypt","text":"decrypt(key::PrivateKey, ct::Union{Ciphertext, PackedCiphertext})\n\nDecrypts an n-bit message (see Params.n) from an RLWE using the private key. Returns an Array{Bool, 1} object.\n\n\n\n\n\ndecrypt(key::PrivateKey, ct::EncryptedBit)\n\nDecrypts an single-bit message from an LWE using the private key. Returns a Bool object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Ciphertext-transformations-1","page":"API reference","title":"Ciphertext transformations","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"normalize_ciphertext\nsplit_ciphertext\npack_encrypted_bits","category":"page"},{"location":"api.html#SGFHE.normalize_ciphertext","page":"API reference","title":"SGFHE.normalize_ciphertext","text":"normalize_ciphertext(ct::PrivateEncryptedCiphertext)\n\nConverts a space-optimal private-encrypted ciphertext into a generic PackedCiphertext object.\n\n\n\n\n\nnormalize_ciphertext(ct::PublicEncryptedCiphertext)\n\nConverts a space-optimal public-encrypted ciphertext into a generic PackedCiphertext object.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.split_ciphertext","page":"API reference","title":"SGFHE.split_ciphertext","text":"split_ciphertext(ct::Union{Ciphertext, PackedCiphertext})\n\nSplits an RLWE ciphertext (encrypting n bits) into n separate EncryptedBit objects. Returns an Array{EncryptedBit, 1}.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.pack_encrypted_bits","page":"API reference","title":"SGFHE.pack_encrypted_bits","text":"pack_encrypted_bits(\n    bkey::BootstrapKey, rng::Union{AbstractRNG, Nothing},\n    enc_bits::AbstractArray{EncryptedBit, 1})\n\nConverts an array of n EncryptedBit objects (see Params.n) into an RLWE Ciphertext. If nothing is given for rng, the result will be deterministic.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Bootstrap-1","page":"API reference","title":"Bootstrap","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"bootstrap","category":"page"},{"location":"api.html#SGFHE.bootstrap","page":"API reference","title":"SGFHE.bootstrap","text":"bootstrap(\n    bkey::BootstrapKey, rng::Union{AbstractRNG, Nothing},\n    enc_bit1::EncryptedBit, enc_bit2::EncryptedBit)\n\nBased on EncryptedBit objects encrypting bits y1 and y2, produces a tuple of three EncryptedBit objects encrypting y1 & y2, y1 | y2 and xor(y1, y2). If nothing is given for rng, the result will be deterministic.\n\n\n\n\n\n","category":"function"},{"location":"api.html#Internals-1","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api.html#Returned-types-1","page":"API reference","title":"Returned types","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"SGFHE.PrivateEncryptedCiphertext\nSGFHE.PublicEncryptedCiphertext\nSGFHE.PackedCiphertext\nSGFHE.Ciphertext\nSGFHE.EncryptedBit","category":"page"},{"location":"api.html#SGFHE.PrivateEncryptedCiphertext","page":"API reference","title":"SGFHE.PrivateEncryptedCiphertext","text":"A space-optimal representation of n bits encrypted with a private key (taking 6n bits in total).\n\n\n\n\n\n","category":"type"},{"location":"api.html#SGFHE.PublicEncryptedCiphertext","page":"API reference","title":"SGFHE.PublicEncryptedCiphertext","text":"A space-optimal representation of n bits encrypted with a public key (taking (10 + log2(n))n bits in total).\n\n\n\n\n\n","category":"type"},{"location":"api.html#SGFHE.PackedCiphertext","page":"API reference","title":"SGFHE.PackedCiphertext","text":"A packed RLWE ciphertext encrypting an n-bit message that can be produced by an initial encryption with a private or a public key. Takes 2 * t * n bits, where t is the bit size of the integer type used.\n\n\n\n\n\n","category":"type"},{"location":"api.html#SGFHE.Ciphertext","page":"API reference","title":"SGFHE.Ciphertext","text":"An RLWE ciphertext encrypting an n-bit message that can be produced by joining together n EncryptedBit objects. Takes 16 * t * n bits, where t is the bit size of the integer type used.\n\n\n\n\n\n","category":"type"},{"location":"api.html#SGFHE.EncryptedBit","page":"API reference","title":"SGFHE.EncryptedBit","text":"An LWE ciphertext encrypting a single bit.\n\n\n\n\n\n","category":"type"},{"location":"api.html#Internal-functions-1","page":"API reference","title":"Internal functions","text":"","category":"section"},{"location":"api.html#","page":"API reference","title":"API reference","text":"find_modulus\nprng_expand\nreduce_modulus\nflatten\nflatten_poly\nexternal_product\nshortened_external_product\nextract","category":"page"},{"location":"api.html#SGFHE.find_modulus","page":"API reference","title":"SGFHE.find_modulus","text":"Find a residue ring modulus q that:\n\nqmin <= q <= qmax\nq is prime\nq - 1 is a multiple of n\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.prng_expand","page":"API reference","title":"SGFHE.prng_expand","text":"prng_expand(seq::BitArray{1}, factor::Int)\n\nExpands a sequence of n bits into a pseudo-random array of n * factor bits deterministically, representing each factor bits as an integer.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.reduce_modulus","page":"API reference","title":"SGFHE.reduce_modulus","text":"function reduce_modulus(\n    new_repr, new_base_type, new_modulus::Unsigned,\n    x::Union{<:AbstractModUInt, Polynomial{<:AbstractModUInt}},\n    floor_result::Bool=false,\n    new_max::Union{Nothing, Unsigned}=nothing)\n\nReduces the modulus of the given value or all coefficients of the given polynomial, simultaneously casting them to the residue ring representation new_repr and type new_base_type. If floor_result is true, use flooring when rescaling, otherwise use rounding. If new_max is nothing, it is taken equal to new_modulus.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.flatten","page":"API reference","title":"SGFHE.flatten","text":"triangleleft operator in the paper.\n\nReturns an l-tuple b such that sum(b .* B.^(0:l-1)) == a. (with all the operations performed in the residue ring a belongs to).\n\nAssumes B^l <= q where q is the modulus of a.\n\n\n\n\n\nflatten(rng::Nothing, a::AbstractModUInt, ::Val{B}, ::Val{l})\n\nThe result is deterministic, and each element of the returned tuple -B/2 < b[i] <= B/2 (where the comparisons are modulo modulus(a)).\n\n\n\n\n\nflatten(rng::AbstractRNG, a::AbstractModUInt, ::Val{B}, ::Val{l})\n\nThe result is randomized, and each element of the returned tuple -2B < b[i] <= 2B (where the comparisons are modulo modulus(a)).\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.flatten_poly","page":"API reference","title":"SGFHE.flatten_poly","text":"function flatten_poly(\n    rng::Union{AbstractRNG, Nothing},\n    a::Polynomial{<:AbstractModUInt}, B_val::Val{B}, l_val::Val{l})\n\nApplies flatten to each of the coefficients of the polynomial, and return a tuple of l polynomials, where the i-th polynomial is created out of i-th elements of the returned tuples.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.external_product","page":"API reference","title":"SGFHE.external_product","text":"external_product(\n    rng::Union{AbstractRNG, Nothing},\n    a::Polynomial{T, N}, b::Polynomial{T, N},\n    A::Array{Polynomial{T, N}, 2}, B_val::Val, l_val::Val)\n\nodot operator in the paper. Returns [flatten(a); flatten(b)] * A. If rng is nothing, deterministic flattening is used.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.shortened_external_product","page":"API reference","title":"SGFHE.shortened_external_product","text":"shortened_external_product(\n    rng::Union{AbstractRNG, Nothing},\n    a::Polynomial{T, N}, A::Array{Polynomial{T, N}, 2}, B_val::Val, l_val::Val)\n\nodot operator in the paper. Returns flatten(a) * A[l+1:2l,:]. If rng is nothing, deterministic flattening is used.\n\n\n\n\n\n","category":"function"},{"location":"api.html#SGFHE.extract","page":"API reference","title":"SGFHE.extract","text":"extract(a::Polynomial, i::Integer, n::Integer)\n\nExtract a sub-array of length n from the polynomial coefficients.\n\n\n\n\n\n","category":"function"},{"location":"theory.html#Theory-1","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"This section contains an extract from S. Gao, \"Efficient fully homomorphic encryption scheme\" with the algorithms used in the package. For the extended discussion and proofs please refer to the original paper.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The algorithms described here have some minor changes as compared to the original paper, which preserve the mathematical idea behind them, but make implementation more straightforward. For example, all operations in this section are performed on unsigned integers, while the original paper has some expressions where signed and unsigned (modulo) integers are mixed and the conversion is performed implicitly. There are some minor changes in notation as well.","category":"page"},{"location":"theory.html#Notation-1","page":"Theory","title":"Notation","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"mathbbZ_q = mathbbZqmathbbZ is the ring of integers modulo q, and R_nq = mathbbZx(x^n+1 q) is a ring of polynomials modulo x^n+1 (that is, negacyclic) with the coefficients from mathbbZ_q.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Vectors are denoted by bold-style symbols: boldsymbola and treated as row vectors. Their elements are accessed as a_i. Matrices are denoted by capital letters: A. Polynomials are denoted by writing their parameter explicitly: a(x).","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"A polynomial can be created out of a vector of coefficients with the operator mathcalPboldsymbola = sum_i=0^n-1 a_i x^i, where boldsymbola in mathbbZ_q^n. By default, the result is belongs to R_nq, although it may be treated as belonging to some R_mQ with m ge n and Q ge q, in which case it will be stated explicitly.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Conversely, a vector of coefficients can be created out of a polynomial with the operator mathcalCa(x) = mathcalCmathcalPboldsymbola = a_i.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"x div y equiv lfloor xy rfloor denotes floor division of unsigned integers.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"mathcalU(a b) denotes a uniform random integer from the range a b.","category":"page"},{"location":"theory.html#Negative-powers-in-polynomials-1","page":"Theory","title":"Negative powers in polynomials","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"We make an occasional use of polynomials where some terms have negative powers (see Bootstrap and Packing LWEs), that is linear combinations of expressions x^-j mathrmmod(x^n+1). The modulus in this case is formally taken as","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"x^-j mathrmmod(x^n+1)\n= x^-j - x^-j (x^n+1)\n= -x^n-j","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"In other words, the \"left shift\" operation (division by x^j) works the same way as the \"right shift\" operation (multiplication by x^j): if the term crosses the boundary of 0 or n-1, respectively, its coefficient changes sign.","category":"page"},{"location":"theory.html#Helper-functions-1","page":"Theory","title":"Helper functions","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"This subsection describes some utility functions used in the FHE scheme.","category":"page"},{"location":"theory.html#Pseudo-random-expansion-(\\mathrm{Expand})-1","page":"Theory","title":"Pseudo-random expansion (mathrmExpand)","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 4.1.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: prng_expand()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Pseudo-random expansion mathrmExpand(boldsymbolu t) where boldsymbolu in 0 1^n produces a pseudo-random bit matrix boldsymbolV in 0 1^n times t, using boldsymbolu as the seed. The result is converted to boldsymbola in mathbbZ^n by treating each row as the bit representation of an unsigned integer:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"a_i = sum_j=0^t V_ij 2^j quad i = 0 dots n-1","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"See the paper for the discussion about the properties the PRNG must have and possible implementations.","category":"page"},{"location":"theory.html#Subvector-extraction-(\\mathrm{Extract})-1","page":"Theory","title":"Subvector extraction (mathrmExtract)","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 3.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: extract()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The function mathrmExtractboldsymbola i n, where boldsymbola in mathbbZ_q^m, m ge n, and 0 le i  m is defined as","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"if i  n - 1,\nmathrmExtractboldsymbola i n = (a_i a_i-1 dots a_0 -a_m-1 -a_m-2 dots -a_m-1-i)\notherwise,\nmathrmExtractboldsymbola i n = (a_i a_i-1 dots a_i-n+1)","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The result is a vector in mathbbZ_q^n.","category":"page"},{"location":"theory.html#Modulus-reduction-(\\mathrm{ModRed})-1","page":"Theory","title":"Modulus reduction (mathrmModRed)","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Lemma 2.3.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: reduce_modulus()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The function mathrmModReda q_1 q_2 where 0 le x  q_1 and q_2  q_1 scales a in mathbbZ_q_1 to a new modulus proportionally, with the result being in mathbbZ_q_2:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"mathrmModReda q_1 q_2 = leftlfloor fraca q_2q_1 rightrceil mathrmmodq_2","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Optionally, flooring (lfloor rfloor) can be used instead of rounding; we will denote this case mathrmModReda q_1 q_2 mathrmfloor.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"mathrmModRed can be applied to a vector, converting each of its elements. That is, if boldsymbolb = mathrmModRedboldsymbola q_1 q_2, then the elements of boldsymbolb are b_i = mathrmModReda_i q_1 q_2.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Furthermore, mathrmModRed can be applied to the objects of belonging to mathbbZ_q^n times mathbbZ_q (in particular, LWE ciphers), as","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"mathrmModRed(boldsymbola b) q_1 q_2\n= (mathrmModRedboldsymbola q_1 q_2 mathrmModRedb q_1 q_2)","category":"page"},{"location":"theory.html#Flattening-1","page":"Theory","title":"Flattening (triangleleft)","text":"","category":"section"},{"location":"theory.html#Integer-flattening-1","page":"Theory","title":"Integer flattening","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 2.5.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: flatten()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given a in mathbbZ_q, and positive integers B and ell, B^ell ge q, a can be uniquely decomposed into a vector boldsymbolu in mathbbZ_q^ell such that","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"a = sum_j=0^ell-1 u_j B^j mathrmmodq","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"where 0 le u_j  B. This can be done simply by successive division of a by B^j, j = ell-1 dots 0, storing the result as u_j and substituting the remainder for a in the next iteration.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Since in the above equation the right side is calculated modulo q, we can shift the range of the elements of boldsymbolu to any interval of length B: s le u_j  s + B. This can be done by first adding the offset to a:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"a^prime = a + s sum_j=0^ell-1 B^j mathrmmodq","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Then the resulting a^prime is flattened as described above, into boldsymbolu^prime. Finally, the offset is subtracted from each element of the result:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"u_j = u_j^prime - s mathrmmodq","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"In this FHE scheme the interval is chosen to be -B2  u_j le B2 (and since we are dealing with non-negative numbers, comparisons undestood modulo q, that is u_j le B2 or u_j  q - B2), so in the algorithm above s = B2-1 (-1 to account for the left side of the interval being open instead of closed).","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"We denote this operation boldsymbolu = a triangleleft (B ell).","category":"page"},{"location":"theory.html#Random-integer-flattening-1","page":"Theory","title":"Random integer flattening","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Lemma 2.4.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: flatten()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The operation above can be randomized by allowing the result's elements to lie in a larger interval, in our case -2B  u_j le 2B (with comparisons again understood modulo q):","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Generate v_j = mathcalU(-3B2 3B2), j = 0 dots ell-1.\nFlatten deterministically boldsymbolu^prime = (a - sum_j=0^ell-1 v_j B^j mathrmmodq) triangleleft (B ell).\nThe result boldsymbolu has elements u_j = u^prime_j + v_j mathrmmodq.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"We use the same symbol for both deterministic and random flattening, because the choice of either does not affect the algorithms that use them (other than making their results deterministic or random, respectively).","category":"page"},{"location":"theory.html#Polynomial-flattening-1","page":"Theory","title":"Polynomial flattening","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 2.5.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: flatten()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"When the flattening operation is applied to a polynomial a(x) in R_nq, we decompose every coefficient separately and use the results to construct ell polynomials:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"a(x) triangleleft (B ell) = (u_0(x) dots u_ell-1(x)) in R_nq^ell","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"where","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"mathcalCu_j(x)_i = left( mathcalCa(x)_i triangleleft (B ell) right)_j\nquad i = 0 dots n-1j = 0 dots ell-1","category":"page"},{"location":"theory.html#External-product-1","page":"Theory","title":"External product (odot)","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 2.5.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: external_product()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"External product acts on a two-element vector of polynomials (a(x) b(x)) in R_nq^2 and a matrix of polynomials A in R_nq^2ell times 2:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"boldsymbolv odot (A B ell)\n  = left(\n    a(x) triangleleft (B ell) b(x) triangleleft (B ell)\n  right) A in R_nq^2","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"where the results of applying triangleleft to a(x) and b(x) (each an ell-vector of polynomials) are concatenated, producing a 2ell-vector.","category":"page"},{"location":"theory.html#Shortened-external-product-1","page":"Theory","title":"Shortened external product (odot)","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 2.5.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: shortened_external_product()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"This is a version of the external product acting on a single polynomial a(x) in R_nq and a matrix of polynomials A in R_nq^2ell times 2:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"boldsymbola odot (A B ell) = left( a(x) triangleleft (B ell) right) A_ell+1 dots 2ell dots in R_nq^2","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"where A_ell+1 dots 2ell dots denotes the bottom half of the matrix A (the rows from ell+1 to 2ell).","category":"page"},{"location":"theory.html#Scheme-parameters-theory-1","page":"Theory","title":"Scheme parameters","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 4.1.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: Params","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The constants introduced here will be used throughout the rest of the section.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The main parameter of the FHE scheme is the polynomial length n ge 64, which must be a power of 2.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Other parameters that need to be chosen:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"LWE modulus is set to r = 16n (it is possible to pick any r = 16n as long as r is divisible by 8, which will require several minor adjustments in the algorithms; see the paper for details).\nRLWE modulus q = nr. In this implementation we choose a prime q such that q-1 is divisible by 2n (to be able to multiply polynomials of length n using NTT).\nDecomposition length ell = 2. See Flattening for details. Note that this value is \"hardcoded\" in the bootstrap modulus Q below (Q le B^ell), so it cannot be trivially adjusted.\nBootstrap modulus 1220 r^4 n^2 le Q le 1225 r^4 n^2 = B^2 (see below for the value of B). Again, we choose a prime Q such that Q-1 is divisible by 2m (to be able to multiply polynomials of length m using NTT).","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Dependent parameters:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Extended polynomial length for bootstrapping m = r  2.\nDecomposition base B = 35 r^2 n. See Flattening for details.\nLWE error level D_r = r4.\nRLWE error level D_q = q div 4.\nBootstrap error level tildeD_Q = Q div 8.\nLower limit for the bit size of LWE elements t = lceil log_2 r rceil - 1 (so 2^t  r le 2^t+1).","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"We will also need the gadget matrix G in mathbbZ_Q^2ell times 2","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"G = beginbmatrix\n    1  0 \n    B  0 \n    dots  0 \n    B^ell-1  0 \n    0  1 \n    0  B \n    0  dots \n    0  B^ell-1 \nendbmatrix","category":"page"},{"location":"theory.html#Private-key-generation-1","page":"Theory","title":"Private key generation","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 4.1.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: PrivateKey","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"A private key is simply a vector boldsymbols in  0 1 ^n with the elements s_i = mathcalU(0 1), i in 0 n-1.","category":"page"},{"location":"theory.html#Private-key-encryption-to-an-RLWE-1","page":"Theory","title":"Private key encryption to an RLWE","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Fig. 2.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: encrypt","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"A private key boldsymbols in  0 1 ^n;\nAn n-bit message to encrypt boldsymbolm  in  0 1 ^n.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Algorithm:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Generate boldsymbolu in  0 1 ^n, u_i = mathcalU(0 1).\nExpand it into a random polynomial:\nboldsymbola = mathrmExpandboldsymbolu t+1 \na(x) = mathcalPboldsymbola in R_nr\nGenerate\nboldsymbolw in mathbbZ_r^n  w_i = mathcalU(-D_r div 8 D_r div 8) mathrmmodr \nw(x) = mathcalPboldsymbolw in R_nr\nCalculate\nb(x) = a(x) s(x) + w(x) + mathcalPboldsymbolm D_r mathrmmod(x^n+1r)\nLeave only the highmost 5 bits of each coefficient of b(x) set:\nb(x) = 2^t-4 (b(x) div 2^t-4)","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: an RLWE cipher (a(x)b(x)) in R_nr^2.","category":"page"},{"location":"theory.html#Space-optimal-representation-private-1","page":"Theory","title":"Space-optimal representation","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Fig. 2.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: encrypt_optimal","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Starting from where the algorithm in the previous section ended,","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Calculate tildeb(x) = b(x) div 2^t-4 (remember, only highest 5 bits of each coefficient of b(x) are set).\nConvert the vector tildeboldsymbolb = mathcalCtildeb(x) into a matrix V in 0 1^n times 5 where the i-th row is the bit representation of tildeb_i.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: a pair (boldsymbolu V) in 0 1^n times 0 1^n times 5.","category":"page"},{"location":"theory.html#Restoring-from-the-space-optimal-representation-1","page":"Theory","title":"Restoring from the space-optimal representation","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Fig. 2.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: normalize_ciphertext","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given a pair (boldsymbolu V) in 0 1^n times 0 1^n times 5:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Expand boldsymbolu into a polynomial:\nboldsymbola = mathrmExpandboldsymbolu t+1 \na(x) = mathcalPboldsymbola in R_nr\nConvert V into a polynomial:\ntildeboldsymbolb in mathbbZ_r^n  tildeb_i = sum_j=0^4 V_ij 2^j \nb(x) = 2^t-4 mathcalPtildeboldsymbolb","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: an RLWE cipher (a(x)b(x)) in R_nr^2.","category":"page"},{"location":"theory.html#Public-key-generation-1","page":"Theory","title":"Public key generation","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 4.1.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: PrivateKey","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given a private key boldsymbols in  0 1 ^n:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Generate\nboldsymbolk^(0) in mathbbZ_q^n k^(0)_i = mathcalU(0 q-1)\nGenerate\nboldsymbole in mathbbZ_q^n e_i = mathcalU(-c c)\nwhere c is the largest integer such that c  D_q  (41n).\nCalculate\nk^(1)(x) = k^(0)(x) s(x) + e(x) mathrmmod(x^n+1 q)","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: a pair (k^(0)(x) k^(1)(x)) in R_nq^2.","category":"page"},{"location":"theory.html#Public-key-encryption-to-an-RLWE-1","page":"Theory","title":"Public key encryption to an RLWE","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Fig. 3.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: encrypt()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"A public key (k^(0)(x) k^(1)(x)) in R_nq^2;\nA message to encrypt boldsymbolm in 0 1^n.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Algorithm:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Generate\nboldsymbolu in mathbbZ_q^n mathcalCu(x)_i = mathcalU(-1 1) \nu(x) = mathcalPboldsymbolu in R_nq\nGenerate\nboldsymbolw^(1) in mathbbZ_q^n w^(1)_i = mathcalU(-D_q(41n) D_q(41n)) mathrmmodq \nw^(1)(x) = mathcalPboldsymbolw^(1) in R_nq\nGenerate\nboldsymbolw^(2) in mathbbZ_q^n mathcalU(-D_q82 D_q82) mathrmmodq \nw^(2)(x) = mathcalPboldsymbolw^(2) in R_nq\nCalculate\na_1(x) = k^(0)(x) u(x) + w^(1)(x) mathrmmod(x^n+1 q) \nb_1(x) = k^(1)(x) u(x) + w^(2)(x) + m(x) D_q mathrmmod(x^n+1 q)\nCalculate\na(x) = mathrmModReda_1(x) q r \nb(x) = 2^t-5 mathrmModRedb_1(x) q r div 2^t-5 mathrmfloor\n(only highmost 6 bits of each coefficient of b(x) are set).","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: an RLWE cipher (a(x)b(x)) in R_nr^2.","category":"page"},{"location":"theory.html#Space-optimal-representation-1","page":"Theory","title":"Space-optimal representation","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Fig. 3.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: encrypt_optimal()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Starting from where the algorithm in the previous section ended,","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Calculate tildeb(x) = b(x) div 2^t-5 (remember, only highmost 6 bits of each coefficient of b(x) are set).\nConvert the vector tildeboldsymbolb = mathcalCtildeb(x) into a matrix V in 0 1^n times 6 where the i-th row is the bit representation of tildeb_i.\nConvert the vector boldsymbola = mathcalCa(x) into a matrix U in 0 1^n times (t+1) where the i-th row is the bit representation of a_i.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: a pair (U V) in 0 1^n times (t+1) times 0 1^n times 6.","category":"page"},{"location":"theory.html#Restoring-from-the-space-optimal-representation-2","page":"Theory","title":"Restoring from the space-optimal representation","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Fig. 3.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: normalize_ciphertext()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given a pair (U V) in 0 1^n times (t+1) times 0 1^n times 6:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Convert U into a polynomial:\nboldsymbola in mathbbZ_r^n a_i = sum_j=0^t U_ij 2^j \na(x) = mathcalPboldsymbola in R_nr\nConvert V into a polynomial:\ntildeboldsymbolb in mathbbZ_r^n tildeb_i = sum_j=0^t V_ij 2^j \nb(x) = 2^t-5 mathcalPtildeboldsymbola in R_nr","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: an RLWE cipher (a(x)b(x)) in R_nr^2.","category":"page"},{"location":"theory.html#Creating-LWEs-1","page":"Theory","title":"Creating LWEs","text":"","category":"section"},{"location":"theory.html#Private-key-encryption-to-an-LWE-1","page":"Theory","title":"Private key encryption to an LWE","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Note: this is not explicitly described in the paper, but Lemma 2.3 sets the maximum error one can introduce during encryption.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: encrypt()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"a message to encrypt y in 0 1;\na secret key boldsymbols in 0 1^n.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Algorithm:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Generate a vector boldsymbola^prime in mathbbZ_q^n with the elements a^prime_i = mathcalU(0 q-1).\nGenerate e = mathcalU(-tau tau) mathrmmod q where tau = (q (n-3)) div (2r).\nCalculate\nb^prime = boldsymbola cdot boldsymbols + e + y D_q mathrmmod q\nModulus reduction:\nboldsymbola = mathrmModRedboldsymbola^prime q r \nb = mathrmModRedb^prime q r","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: an LWE cipher mathrmLWE_boldsymbols(y) = (boldsymbola b) in mathbbZ_r^n times mathbbZ_r.","category":"page"},{"location":"theory.html#Extracting-an-LWE-from-a-packed-RLWE-1","page":"Theory","title":"Extracting an LWE from a packed RLWE","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 4.5.1.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: split_ciphertext()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given an RLWE cipher mathrmRLWE_boldsymbols(boldsymboly) = (a(x) b(x)) in R_nr^2 encrypting an n-bit message boldsymboly in 0 1^n, the LWE mathrmLWE_boldsymbols(y_i) encrpyting the i-th bit is","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"mathrmLWE_boldsymbols(y_i) = (mathrmExtractmathcalCa(x) i n mathcalCb(x)_i)","category":"page"},{"location":"theory.html#Extracting-an-LWE-from-a-RLWE-1","page":"Theory","title":"Extracting an LWE from a RLWE","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Note: this is not described in the original paper.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: split_ciphertext()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The procedure is the same as for the packed RLWE. Given an RLWE cipher mathrmRLWE_boldsymbols(boldsymboly) = (a(x) b(x)) in R_mr^2 encrypting an n-bit message boldsymboly in 0 1^n, the LWE mathrmLWE_boldsymbols(y_i) encrpyting the i-th bit is","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"mathrmLWE_boldsymbols(y_i) = (mathrmExtractmathcalCa(x) i n mathcalCb(x)_i)","category":"page"},{"location":"theory.html#Decryption-1","page":"Theory","title":"Decryption","text":"","category":"section"},{"location":"theory.html#Decrypting-an-LWE-1","page":"Theory","title":"Decrypting an LWE","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 2.3.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: decrypt()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"An LWE cipher encrypting y in 01 mathrmLWE_boldsymbols(y) = (boldsymbola b) in mathbbZ_r^n times mathbbZ_r;\nA secret key boldsymbols in 0 1^n.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Algorithm:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Calculate\nb_1 = b - boldsymbola cdot boldsymbols + D_r  2 mathrmmodr\nCalculate y = b_1 div D_r.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The addition of D_r  2 as compared to the algorithm provided in the paper allows us to use div (that is, the regular integer floor division by D_r) as compared to lfloor rceil in the paper.","category":"page"},{"location":"theory.html#Decrypting-a-packed-RLWE-1","page":"Theory","title":"Decrypting a packed RLWE","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 4.2.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: decrypt()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"An RLWE cipher encrypting boldsymboly in 01^n mathrmRLWE_boldsymbols(boldsymboly) = (a(x) b(x)) in R_nr^2;\nA secret key boldsymbols in 0 1^n.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Algorithm:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Calculate\nb_1(x) = b(x) - a(x) s(x) mathrmmod(x^n+1 r)\nCalculate\ny_i = (mathcalCb_1(x)_i + D_r  2 mathrmmodr) div D_r\nquad i = 0 dots n-1","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Again, the shift by D_r  2 allows us to use the floor division instead of rounding division.","category":"page"},{"location":"theory.html#Decrypting-an-RLWE-1","page":"Theory","title":"Decrypting an RLWE","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Note: this algorithm is not given in the original paper.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: decrypt()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The algorithm is almost identical to the one for a packed RLWE, with the only change being the polynomial modulus in the first step.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"An RLWE cipher encrypting boldsymboly in 01^n mathrmRLWE_boldsymbols(boldsymboly) = (a(x) b(x)) in R_mr^2;\nA secret key boldsymbols in 0 1^n.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Algorithm:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Calculate\nb_1(x) = b(x) - a(x) s(x) mathrmmod(x^m+1 r)\nCalculate\ny_i = (mathcalCb_1(x)_i + D_r  2 mathrmmodr) div D_r\nquad i = 0 dots n-1","category":"page"},{"location":"theory.html#Bootstrap-key-generation-1","page":"Theory","title":"Bootstrap key generation","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Section 4.1.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: BootstrapKey","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given a secret key boldsymbols in 0 1^n, for each i = 0 dots n-1:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Generate a matrix of polynomials A in R_mQ^2ell times n where\nmathcalCA_ji(x)_k = mathcalU(0 Q-1) quad k = 0 dots n-1\nGenerate a matrix of polynomials E in R_mQ^2ell times n where\nmathcalCE_ji(x)_k = mathcalU(-n n) mathrmmodQ quad k = 0 dots n-1\nCalculate\nB(x) = A(x) mathcalPboldsymbols(x) + E(x) mathrmmod(x^m+1 Q)\nFor i = 0 dots n-1, calculate\nC^(i) = beginbmatrix\n    A_1i(x)  B_1i(x) \n    A_2i(x)  B_2i(x) \n    A_3i(x)  B_3i(x) \n    A_4i(x)  B_4i(x)\nendbmatrix + s_i G mathrmmodQ\nwhere G is the gadget matrix (see Scheme parameters).","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"The resulting bootstrap key is a list of n matrices of polynomials C^(i) in R_mQ^2ell times n.","category":"page"},{"location":"theory.html#Bootstrap-theory-1","page":"Theory","title":"Bootstrap","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Fig. 1.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: bootstrap()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"A bootstrap key –- a list of n matrices of polynomials C^(i) in R_mQ^2ell times n;\nTwo LWE ciphers boldsymbolv_1 = mathrmLWE_boldsymbols(y_1), boldsymbolv_2 = mathrmLWE_boldsymbols(y_2), where boldsymbolv_1 boldsymbolv_2 in mathbbZ^n_r times mathbbZ_r.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Algorithm:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Sum both LWE ciphers element-wise:\nboldsymbolu = boldsymbolv_1 + boldsymbolv_2 = (u_0 dots u_n-1 u_n) in mathbbZ^n_r times mathbbZ_r\nBuild\nt(x) = sum_j=-D_r+1^D_r-1 x^j mathrmmod(x^m+1 Q)\nSee Negative powers in polynomials for the explanation of how the modulus is taken.\nInitilize a(x) b(x) in R_mQ\na(x) = 0 \nb(x) = t(x) x^-u_n tildeD_Q mathrmmod(x^m+1 Q)\nFor i = 0 dots n-1:\nA^(i) = G + (x^u_i - 1) C^(i) mathrmmod(x^m+1 Q) \n(a(x) b(x)) leftarrow (a(x) b(x)) odot (A^(i) B ell)\nwhere G is the gadget matrix (see Scheme parameters) and odot is the external product.\nBuild LWEs\nboldsymbola^mathrmAND = (mathrmExtractboldsymbola 3m4 tildeD_Q + b_3m4) \nboldsymbola^mathrmOR = (-mathrmExtractboldsymbola 3m4 tildeD_Q - b_m4) \nboldsymbola^mathrmXOR = boldsymbola_mathrmOR - boldsymbola_mathrmAND\nwhere\nboldsymbola = mathcalCa(x) in mathbbZ_Q^m \nboldsymbolb = mathcalCb(x) in mathbbZ_Q^m\nModulus reduction:\nboldsymbolc^mathrmAND = mathrmModRedboldsymbola^mathrmAND Q r \nboldsymbolc^mathrmOR = mathrmModRedboldsymbola^mathrmOR Q r \nboldsymbolc^mathrmXOR = mathrmModRedboldsymbola^mathrmXOR Q r\nHere boldsymbolc^mathrmAND boldsymbolc^mathrmOR boldsymbolc^mathrmXOR in mathbbZ_r^n times mathbbZ_r.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: LWE ciphers of y_1 wedge y_2 (AND), y_1 vee y_2 (OR) and y_1 oplus y_2 (XOR):","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"boldsymbolc^mathrmAND = mathrmLWE_boldsymbols(y_1 wedge y_2) \nboldsymbolc^mathrmOR = mathrmLWE_boldsymbols(y_1 vee y_2) \nboldsymbolc^mathrmXOR = mathrmLWE_boldsymbols(y_1 oplus y_2)","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"One can use either the deterministic or the random version of the external product odot, depending on the desired behavior of the bootstrap.","category":"page"},{"location":"theory.html#Packing-LWEs-1","page":"Theory","title":"Packing LWEs","text":"","category":"section"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Paper: Lemma 4.3.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Implementation: pack_encrypted_bits()","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Given:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"n LWE ciphers boldsymbolz^(i) = mathrmLWE_boldsymbols(y_i) in mathbbZ_r^n times mathbbZ_r i = 0 dots n-1;\na bootstrap key C^(i) i = 0 dots n-1.","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Algorithm:","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Create a trivial LWE cipher encrypting 1: mathrmLWE_boldsymbols(1) = (boldsymbol0 D_r) in mathbbZ_r^n times mathbbZ_r.\nFor i = 0 dots n-1 apply the Bootstrap algorithm to the pair E_boldsymbols(1) and boldsymbolz^(i) up to and not including the modulus reduction step, leaving only the first result (corresponding to the AND gate). This will produce n LWEs:\nboldsymbola^mathrmAND(i)\nequiv (boldsymbola^(i) b^(i))\nin mathbbZ_Q^n times mathbbZ_Q\nFor i = 0 dots n-1, build polynomials\ntildea^(i)(x) = mathcalPtildeboldsymbola^(i) in R_mQ\nwhere tildea^(i)_j = a^(j)_i, j = 0 dots n-1. Note that we are treating the resulting polynomials as modulo (x^m+1) despite them only having powers of x up to n-1.\nCreate a polynomial tildeb(x) = mathcalPboldsymbolb in R_mQ. Again, we are treating the resulting polynomial as modulo (x^m+1).\nCalculate:\nleft( tildew(x) tildev(x) right) = sum_i=0^n-1\n  a^(i)(x) odot (C^(i) B ell)\nwhere odot is the shortened external product.\nCalculate:\ntildew_1(x) = -tildew(x) \ntildev_1(x) = b(x) - tildev(x)\nModulus reduction:\nw(x) = mathrmModRedtildew_1(x) Q r \nv(x) = mathrmModRedtildev_1(x) Q r","category":"page"},{"location":"theory.html#","page":"Theory","title":"Theory","text":"Result: an RLWE cipher (w(x) v(x)) in R_mr^2 encrypting the vector boldsymboly.","category":"page"},{"location":"history.html#Version-history-1","page":"Version history","title":"Version history","text":"","category":"section"},{"location":"history.html#v0.0.1-1","page":"Version history","title":"v0.0.1","text":"","category":"section"},{"location":"history.html#","page":"Version history","title":"Version history","text":"Initial version.","category":"page"},{"location":"manual.html#Manual-1","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"DocTestSetup = quote\n    using Random\n    using SGFHE\nend","category":"page"},{"location":"manual.html#Data-flow-1","page":"Manual","title":"Data flow","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The FHE scheme operates with several different representations of ciphertexts, each having its advantages and disadvantages. The scheme below shows the possible transformations between them and can be used as a quick reference.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"(Image: )","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"In the examples in this section we will assume that the following modules are imported:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"using Random\nusing SGFHE","category":"page"},{"location":"manual.html#Private-key-encrpytion-1","page":"Manual","title":"Private key encrpytion","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"We will start with generating a private key use it to encrypt and then decrypt some data. Data can only be encrypted in blocks of size n, which is the polynomial length passed to the Params constructor.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The simplest variant is to encrypt a single bit:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"rng = MersenneTwister()\nparams = Params(64)\nkey = PrivateKey(params, rng)\n\nbits = rand(Bool, params.n)\nencrypted_array = encrypt(key, rng, bits)\ndecrypted_bits = decrypt(key, encrypted_array)\n\n@assert bits == decrypted_bits\n\n# output\n","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Here we used 64 as the polynomial length in the FHE scheme. The polynomial length must be a power of 2 greater than 64, and the larger it is, the more secure the encryption is (and, naturally, the slower it is, too).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"note: Note\nWe need to create an RNG and pass it to some functions explicitly. All functions that in some way use randomness take an RNG as a parameter, and it is the user's responsibility to assure that it is cryptographically secure (the default Julia one, MersenneTwister, isn't, and is only used here for demonstration purposes).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The resulting ciphertext has the expansion coefficient of 2t, where t is the bit size of the integer type used (which is chosen to be able to fit numbers up to 16n, where n is the polynomial length, see the corresponding theory section for details).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"There is a more efficient representation possible, with the expansion coefficient of only 6. It cannot be decrypted directly, and must be normalized first:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"rng = MersenneTwister()\nparams = Params(64)\nkey = PrivateKey(params, rng)\n\nbits = rand(Bool, params.n)\nencrypted_array = encrypt_optimal(key, rng, bits)\ndecrypted_bits = decrypt(key, normalize_ciphertext(encrypted_array))\n\n@assert bits == decrypted_bits\n\n# output\n","category":"page"},{"location":"manual.html#Public-key-encrpytion-1","page":"Manual","title":"Public key encrpytion","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The FHE scheme supports asymmetric encryption. We can generate a public key out of our private key, and distribute it. Anyone can use it to encrpyt data, which can be decrypted only by someone possessing the private key.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"At the moment one can only use a public key to encrypt arrays of bits:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"rng = MersenneTwister()\nparams = Params(64)\nkey = PrivateKey(params, rng)\npkey = PublicKey(rng, key)\n\nbits = rand(Bool, params.n)\nencrypted_bits = encrypt(pkey, rng, bits)\ndecrypted_bits = decrypt(key, encrypted_bits)\n\n@assert bits == decrypted_bits\n\n# output\n","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Similarly to the private key encrpytion, one can use an intermediate space-efficient representation, although the ciphertext expansion coefficient is larger than that for the private key (namely, 10 + log2(n)):","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"rng = MersenneTwister()\nparams = Params(64)\nkey = PrivateKey(params, rng)\npkey = PublicKey(rng, key)\n\nbits = rand(Bool, params.n)\nencrypted_array = encrypt_optimal(pkey, rng, bits)\ndecrypted_bits = decrypt(key, normalize_ciphertext(encrypted_array))\n\n@assert bits == decrypted_bits\n\n# output\n","category":"page"},{"location":"manual.html#Bootstrap-manual-1","page":"Manual","title":"Bootstrap","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The main feature of FHE is being able to perform arbitrary operations on the encrypted data. In the scheme that this package implements, one can take two encrypted bits and obtain ciphertexts encrypting the result of applying AND, OR and XOR operations on the corresponding plaintext bits. This is enough to implement any logical circuit.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Since after the encryption all we have is an encrypted block of bits, it has to be split into single EncryptedBit objects first using the function split_ciphertext. This leads to a significant ciphertext expansion (of the order of kilobytes of data to represent a single bit, depending on the polynomial length). That's why after running the circuit on separate bits it is a good idea to pack them back with pack_encrypted_bits (more on this later).","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Bootstrapping procedure requires a special bootstrap key, which can be generated from the private key:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"rng = MersenneTwister()\nparams = Params(64)\nkey = PrivateKey(params, rng)\nbkey = BootstrapKey(rng, key)\n\nbits = rand(Bool, params.n)\nencrypted_array = encrypt(key, rng, bits)\nencrypted_bits = split_ciphertext(encrypted_array)\n\n# we will run bootstrap() on the 10th and the 20th bit\ni1 = 10\ni2 = 20\n\ny1 = bits[i1]\ny2 = bits[i2]\n\nenc_y1 = encrypted_bits[i1]\nenc_y2 = encrypted_bits[i2]\n\nenc_and, enc_or, enc_xor = bootstrap(bkey, rng, enc_y1, enc_y2)\nres_and, res_or, res_xor = [decrypt(key, enc_bit) for enc_bit in (enc_and, enc_or, enc_xor)]\n\n@assert res_and == y1 & y2\n@assert res_or == y1 | y2\n@assert res_xor == xor(y1, y2)\n\n# output\n","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"If one passes nothing instead of an RNG, bootstrap will be run deterministically, producing the same encrypted bits each time, which may be beneficial for some applications:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"enc1_and, enc1_or, enc1_xor = bootstrap(bkey, nothing, enc_y1, enc_y2)\nenc2_and, enc2_or, enc2_xor = bootstrap(bkey, nothing, enc_y1, enc_y2)\n\n@assert enc1_and == enc2_and\n@assert enc1_or == enc2_or\n@assert enc1_xor == enc2_xor\n\nres_and, res_or, res_xor = [decrypt(key, enc_bit) for enc_bit in (enc1_and, enc1_or, enc1_xor)]\n\n@assert res_and == y1 & y2\n@assert res_or == y1 | y2\n@assert res_xor == xor(y1, y2)\n\n# output\n","category":"page"},{"location":"manual.html#Packing-encrypted-bits-1","page":"Manual","title":"Packing encrypted bits","text":"","category":"section"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"After you finished with your bootstrapped circuit, you are left with a bunch of encrypted bit objects. They are not very efficient in terms of occupied space, so any n (the scheme's polynomial length) encrypted bits can be packed back into an encrypted array. As opposed to an encrypted array created by encrypt, the ciphertext expansion coefficient is 8 times larger (16t instead of 2t, where t is the bit size of the interger type used), but it is still much better than the coefficient of a separate encrypted bit.","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"The packing function uses the bootstrap key:","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"rng = MersenneTwister()\nparams = Params(64)\nkey = PrivateKey(params, rng)\nbkey = BootstrapKey(rng, key)\n\nbits = rand(Bool, params.n)\nencrypted_array = encrypt(key, rng, bits)\nencrypted_bits = split_ciphertext(encrypted_array)\n\nnew_encrypted_array = pack_encrypted_bits(bkey, rng, encrypted_bits)\ndecrypted_bits = decrypt(key, new_encrypted_array)\n\n@assert bits == decrypted_bits\n\n# output\n","category":"page"},{"location":"manual.html#","page":"Manual","title":"Manual","text":"Similarly to the bootstrap, if one passes nothing as an RNG to pack_encrypted_bits, the result will be deterministic.","category":"page"},{"location":"index.html#Shuhong-Gao's-FHE-scheme-1","page":"Home","title":"Shuhong Gao's FHE scheme","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"This package contains a reference implementation of the FHE scheme from S. Gao, \"Efficient fully homomorphic encryption scheme\". The aim is to keep the implementation simple as long as it does not affect the performance too much.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The formal mathematical description of the implemented algorithms can be found in the Theory section, with cross-references to the corresponding functions in API reference. For usage examples and a scheme of possible transformations between different forms of ciphertexts (which is non-trivial), refer to Manual.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A brief usage example:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"using Random\nusing SGFHE\n\nrng = MersenneTwister()\nparams = Params(64)\nkey = PrivateKey(params, rng)\nbkey = BootstrapKey(rng, key)\n\n# Can only encrypt a block of bits at once\nbits = rand(Bool, params.n)\nencrypted_array = encrypt(key, rng, bits)\nencrypted_bits = split_ciphertext(encrypted_array)\n\n# we will run bootstrap() on the 10th and the 20th bit\ni1 = 10\ni2 = 20\n\ny1 = bits[i1]\ny2 = bits[i2]\n\nenc_y1 = encrypted_bits[i1]\nenc_y2 = encrypted_bits[i2]\n\nenc_and, enc_or, enc_xor = bootstrap(bkey, rng, enc_y1, enc_y2)\nres_and, res_or, res_xor = [decrypt(key, enc_bit) for enc_bit in (enc_and, enc_or, enc_xor)]\n\n@assert res_and == y1 & y2\n@assert res_or == y1 | y2\n@assert res_xor == xor(y1, y2)\n\n# output\n","category":"page"}]
}
