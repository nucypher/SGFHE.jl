<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Theory · SGFHE.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">SGFHE.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="manual.html">Manual</a></li><li><a class="tocitem" href="api.html">API reference</a></li><li class="is-active"><a class="tocitem" href="theory.html">Theory</a><ul class="internal"><li><a class="tocitem" href="#Notation-1"><span>Notation</span></a></li><li><a class="tocitem" href="#Helper-functions-1"><span>Helper functions</span></a></li><li><a class="tocitem" href="#Scheme-parameters-theory-1"><span>Scheme parameters</span></a></li><li><a class="tocitem" href="#Private-key-generation-1"><span>Private key generation</span></a></li><li><a class="tocitem" href="#Private-key-encryption-to-an-RLWE-1"><span>Private key encryption to an RLWE</span></a></li><li><a class="tocitem" href="#Public-key-generation-1"><span>Public key generation</span></a></li><li><a class="tocitem" href="#Public-key-encryption-to-an-RLWE-1"><span>Public key encryption to an RLWE</span></a></li><li><a class="tocitem" href="#Creating-LWEs-1"><span>Creating LWEs</span></a></li><li><a class="tocitem" href="#Decryption-1"><span>Decryption</span></a></li><li><a class="tocitem" href="#Bootstrap-key-generation-1"><span>Bootstrap key generation</span></a></li><li><a class="tocitem" href="#Bootstrap-theory-1"><span>Bootstrap</span></a></li><li><a class="tocitem" href="#Packing-LWEs-1"><span>Packing LWEs</span></a></li></ul></li><li><a class="tocitem" href="history.html">Version history</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="theory.html">Theory</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="theory.html">Theory</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/nucypher/SGFHE.jl/blob/master/docs/src/theory.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Theory-1"><a class="docs-heading-anchor" href="#Theory-1">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-1" title="Permalink"></a></h1><p>This section contains an extract from <a href="https://eprint.iacr.org/2018/637">S. Gao, &quot;Efficient fully homomorphic encryption scheme&quot;</a> with the algorithms used in the package. For the extended discussion and proofs please refer to the original paper.</p><p>The algorithms described here have some minor changes as compared to the original paper, which preserve the mathematical idea behind them, but make implementation more straightforward. For example, all operations in this section are performed on unsigned integers, while the original paper has some expressions where signed and unsigned (modulo) integers are mixed and the conversion is performed implicitly. There are some minor changes in notation as well.</p><h2 id="Notation-1"><a class="docs-heading-anchor" href="#Notation-1">Notation</a><a class="docs-heading-anchor-permalink" href="#Notation-1" title="Permalink"></a></h2><p><span>$\mathbb{Z}_q = \mathbb{Z}/q\mathbb{Z}$</span> is the ring of integers modulo <span>$q$</span>, and <span>$R_{n,q} = \mathbb{Z}[x]/(x^n+1, q)$</span> is a ring of polynomials modulo <span>$x^n+1$</span> (that is, negacyclic) with the coefficients from <span>$\mathbb{Z}_q$</span>.</p><p>Vectors are denoted by bold-style symbols: <span>$\boldsymbol{a}$</span> and treated as row vectors. Their elements are accessed as <span>$a_i$</span>. Matrices are denoted by capital letters: <span>$A$</span>. Polynomials are denoted by writing their parameter explicitly: <span>$a(x)$</span>.</p><p>A polynomial can be created out of a vector of coefficients with the operator <span>$\mathcal{P}[\boldsymbol{a}] = \sum_{i=0}^{n-1} a_i x^i$</span>, where <span>$\boldsymbol{a} \in \mathbb{Z}_q^n$</span>. By default, the result is belongs to <span>$R_{n,q}$</span>, although it may be treated as belonging to some <span>$R_{m,Q}$</span> with <span>$m \ge n$</span> and <span>$Q \ge q$</span>, in which case it will be stated explicitly.</p><p>Conversely, a vector of coefficients can be created out of a polynomial with the operator <span>$\mathcal{C}[a(x)] = \mathcal{C}[\mathcal{P}[\boldsymbol{a}]] = a_i$</span>.</p><p><span>$x \div y \equiv \lfloor x/y \rfloor$</span> denotes floor division of unsigned integers.</p><p><span>$\mathcal{U}(a, b)$</span> denotes a uniform random integer from the range <span>$[a, b]$</span>.</p><h3 id="Negative-powers-in-polynomials-1"><a class="docs-heading-anchor" href="#Negative-powers-in-polynomials-1">Negative powers in polynomials</a><a class="docs-heading-anchor-permalink" href="#Negative-powers-in-polynomials-1" title="Permalink"></a></h3><p>We make an occasional use of polynomials where some terms have negative powers (see <a href="theory.html#Bootstrap-theory-1">Bootstrap</a> and <a href="theory.html#Packing-LWEs-1">Packing LWEs</a>), that is linear combinations of expressions <span>$x^{-j} \,\mathrm{mod}\,(x^n+1)$</span>. The modulus in this case is formally taken as</p><div>\[x^{-j} \,\mathrm{mod}\,(x^n+1)
= x^{-j} - x^{-j} (x^n+1)
= -x^{n-j}.\]</div><p>In other words, the &quot;left shift&quot; operation (division by <span>$x^j$</span>) works the same way as the &quot;right shift&quot; operation (multiplication by <span>$x^j$</span>): if the term crosses the boundary of <span>$0$</span> or <span>$n-1$</span>, respectively, its coefficient changes sign.</p><h2 id="Helper-functions-1"><a class="docs-heading-anchor" href="#Helper-functions-1">Helper functions</a><a class="docs-heading-anchor-permalink" href="#Helper-functions-1" title="Permalink"></a></h2><p>This subsection describes some utility functions used in the FHE scheme.</p><h3 id="Pseudo-random-expansion-(\\mathrm{Expand})-1"><a class="docs-heading-anchor" href="#Pseudo-random-expansion-(\\mathrm{Expand})-1">Pseudo-random expansion (<span>$\mathrm{Expand}$</span>)</a><a class="docs-heading-anchor-permalink" href="#Pseudo-random-expansion-(\\mathrm{Expand})-1" title="Permalink"></a></h3><p><em>Paper:</em> Section 4.1.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.prng_expand"><code>prng_expand()</code></a></p><p>Pseudo-random expansion <span>$\mathrm{Expand}(\boldsymbol{u}, t)$</span> where <span>$\boldsymbol{u} \in \{0, 1\}^n$</span> produces a pseudo-random bit matrix <span>$\boldsymbol{V} \in \{0, 1\}^{n \times t}$</span>, using <span>$\boldsymbol{u}$</span> as the seed. The result is converted to <span>$\boldsymbol{a} \in \mathbb{Z}^n$</span> by treating each row as the bit representation of an unsigned integer:</p><div>\[a_i = \sum_{j=0}^t V_{ij} 2^j, \quad i = 0, \dots, n-1.\]</div><p>See the paper for the discussion about the properties the PRNG must have and possible implementations.</p><h3 id="Subvector-extraction-(\\mathrm{Extract})-1"><a class="docs-heading-anchor" href="#Subvector-extraction-(\\mathrm{Extract})-1">Subvector extraction (<span>$\mathrm{Extract}$</span>)</a><a class="docs-heading-anchor-permalink" href="#Subvector-extraction-(\\mathrm{Extract})-1" title="Permalink"></a></h3><p><em>Paper:</em> Section 3.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.extract"><code>extract()</code></a></p><p>The function <span>$\mathrm{Extract}[\boldsymbol{a}, i, n]$</span>, where <span>$\boldsymbol{a} \in \mathbb{Z}_q^m$</span>, <span>$m \ge n$</span>, and <span>$0 \le i &lt; m$</span> is defined as</p><ul><li>if <span>$i &lt; n - 1$</span>,<div>\[\mathrm{Extract}[\boldsymbol{a}, i, n] = (a_i, a_{i-1}, \dots, a_0, -a_{m-1}, -a_{m-2}, \dots, -a_{m-1-i}),\]</div></li><li>otherwise,<div>\[\mathrm{Extract}[\boldsymbol{a}, i, n] = (a_i, a_{i-1}, \dots, a_{i-n+1}).\]</div></li></ul><p>The result is a vector in <span>$\mathbb{Z}_q^n$</span>.</p><h3 id="Modulus-reduction-(\\mathrm{ModRed})-1"><a class="docs-heading-anchor" href="#Modulus-reduction-(\\mathrm{ModRed})-1">Modulus reduction (<span>$\mathrm{ModRed}$</span>)</a><a class="docs-heading-anchor-permalink" href="#Modulus-reduction-(\\mathrm{ModRed})-1" title="Permalink"></a></h3><p><em>Paper:</em> Lemma 2.3.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.reduce_modulus"><code>reduce_modulus()</code></a></p><p>The function <span>$\mathrm{ModRed}[a, q_1, q_2]$</span> where <span>$0 \le x &lt; q_1$</span> and <span>$q_2 &lt; q_1$</span> scales <span>$a \in \mathbb{Z}_{q_1}$</span> to a new modulus proportionally, with the result being in <span>$\mathbb{Z}_{q_2}$</span>:</p><div>\[\mathrm{ModRed}[a, q_1, q_2] = \left\lfloor \frac{a q_2}{q_1} \right\rceil \,\mathrm{mod}\,q_2.\]</div><p>Optionally, flooring (<span>$\lfloor \rfloor$</span>) can be used instead of rounding; we will denote this case <span>$\mathrm{ModRed}[a, q_1, q_2, \mathrm{floor}]$</span>.</p><p><span>$\mathrm{ModRed}$</span> can be applied to a vector, converting each of its elements. That is, if <span>$\boldsymbol{b} = \mathrm{ModRed}[\boldsymbol{a}, q_1, q_2]$</span>, then the elements of <span>$\boldsymbol{b}$</span> are <span>$b_i = \mathrm{ModRed}[a_i, q_1, q_2]$</span>.</p><p>Furthermore, <span>$\mathrm{ModRed}$</span> can be applied to the objects of belonging to <span>$\mathbb{Z}_q^n \times \mathbb{Z}_q$</span> (in particular, <a href="theory.html#Creating-LWEs-1">LWE ciphers</a>), as</p><div>\[\mathrm{ModRed}[(\boldsymbol{a}, b), q_1, q_2]
= (\mathrm{ModRed}[\boldsymbol{a}, q_1, q_2], \mathrm{ModRed}[b, q_1, q_2]).\]</div><h3 id="Flattening-1"><a class="docs-heading-anchor" href="#Flattening-1">Flattening (<span>$\triangleleft$</span>)</a><a class="docs-heading-anchor-permalink" href="#Flattening-1" title="Permalink"></a></h3><h4 id="Integer-flattening-1"><a class="docs-heading-anchor" href="#Integer-flattening-1">Integer flattening</a><a class="docs-heading-anchor-permalink" href="#Integer-flattening-1" title="Permalink"></a></h4><p><em>Paper:</em> Section 2.5.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.flatten"><code>flatten()</code></a></p><p>Given <span>$a \in \mathbb{Z}_q$</span>, and positive integers <span>$B$</span> and <span>$\ell$</span>, <span>$B^\ell \ge q$</span>, <span>$a$</span> can be uniquely decomposed into a vector <span>$\boldsymbol{u} \in \mathbb{Z}_q^\ell$</span> such that</p><div>\[a = \sum_{j=0}^{\ell-1} u_j B^j \,\mathrm{mod}\,q,\]</div><p>where <span>$0 \le u_j &lt; B$</span>. This can be done simply by successive division of <span>$a$</span> by <span>$B^j$</span>, <span>$j = \ell-1 \dots 0$</span>, storing the result as <span>$u_j$</span> and substituting the remainder for <span>$a$</span> in the next iteration.</p><p>Since in the above equation the right side is calculated modulo <span>$q$</span>, we can shift the range of the elements of <span>$\boldsymbol{u}$</span> to any interval of length <span>$B$</span>: <span>$s \le u_j &lt; s + B$</span>. This can be done by first adding the offset to <span>$a$</span>:</p><div>\[a^\prime = a + s \sum_{j=0}^{\ell-1} B^j \,\mathrm{mod}\,q.\]</div><p>Then the resulting <span>$a^\prime$</span> is flattened as described above, into <span>$\boldsymbol{u}^\prime$</span>. Finally, the offset is subtracted from each element of the result:</p><div>\[u_j = u_j^\prime - s \,\mathrm{mod}\,q.\]</div><p>In this FHE scheme the interval is chosen to be <span>$-B/2 &lt; u_j \le B/2$</span> (and since we are dealing with non-negative numbers, comparisons undestood modulo <span>$q$</span>, that is <span>$u_j \le B/2$</span> or <span>$u_j &gt; q - B/2$</span>), so in the algorithm above <span>$s = B/2-1$</span> (<span>$-1$</span> to account for the left side of the interval being open instead of closed).</p><p>We denote this operation <span>$\boldsymbol{u} = a \triangleleft (B, \ell)$</span>.</p><h4 id="Random-integer-flattening-1"><a class="docs-heading-anchor" href="#Random-integer-flattening-1">Random integer flattening</a><a class="docs-heading-anchor-permalink" href="#Random-integer-flattening-1" title="Permalink"></a></h4><p><em>Paper:</em> Lemma 2.4.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.flatten"><code>flatten()</code></a></p><p>The operation above can be randomized by allowing the result&#39;s elements to lie in a larger interval, in our case <span>$-2B &lt; u_j \le 2B$</span> (with comparisons again understood modulo <span>$q$</span>):</p><ul><li>Generate <span>$v_j = \mathcal{U}(-3B/2, 3B/2)$</span>, <span>$j = 0, \dots, \ell-1$</span>.</li><li>Flatten deterministically <span>$\boldsymbol{u}^\prime = (a - \sum_{j=0}^{\ell-1} v_j B^j \,\mathrm{mod}\,q) \triangleleft (B, \ell)$</span>.</li><li>The result <span>$\boldsymbol{u}$</span> has elements <span>$u_j = u^\prime_j + v_j \,\mathrm{mod}\,q$</span>.</li></ul><p>We use the same symbol for both deterministic and random flattening, because the choice of either does not affect the algorithms that use them (other than making their results deterministic or random, respectively).</p><h4 id="Polynomial-flattening-1"><a class="docs-heading-anchor" href="#Polynomial-flattening-1">Polynomial flattening</a><a class="docs-heading-anchor-permalink" href="#Polynomial-flattening-1" title="Permalink"></a></h4><p><em>Paper:</em> Section 2.5.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.flatten_poly"><code>flatten()</code></a></p><p>When the flattening operation is applied to a polynomial <span>$a(x) \in R_{n,q}$</span>, we decompose every coefficient separately and use the results to construct <span>$\ell$</span> polynomials:</p><div>\[a(x) \triangleleft (B, \ell) = (u_0(x), \dots, u_{\ell-1}(x)) \in R_{n,q}^\ell,\]</div><p>where</p><div>\[\mathcal{C}[u_j(x)]_i = \left( \mathcal{C}[a(x)]_i \triangleleft (B, \ell) \right)_j,
\quad i = 0, \dots, n-1,\,j = 0, \dots, \ell-1.\]</div><h3 id="External-product-1"><a class="docs-heading-anchor" href="#External-product-1">External product (<span>$\odot$</span>)</a><a class="docs-heading-anchor-permalink" href="#External-product-1" title="Permalink"></a></h3><p><em>Paper:</em> Section 2.5.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.external_product"><code>external_product()</code></a></p><p>External product acts on a two-element vector of polynomials <span>$(a(x), b(x)) \in R_{n,q}^2$</span> and a matrix of polynomials <span>$A \in R_{n,q}^{2\ell \times 2}$</span>:</p><div>\[\boldsymbol{v} \odot (A, B, \ell)
  = \left(
    a(x) \triangleleft (B, \ell), b(x) \triangleleft (B, \ell)
  \right) A \in R_{n,q}^2,\]</div><p>where the results of applying <span>$\triangleleft$</span> to <span>$a(x)$</span> and <span>$b(x)$</span> (each an <span>$\ell$</span>-vector of polynomials) are concatenated, producing a <span>$2\ell$</span>-vector.</p><h3 id="Shortened-external-product-1"><a class="docs-heading-anchor" href="#Shortened-external-product-1">Shortened external product (<span>$\odot$</span>)</a><a class="docs-heading-anchor-permalink" href="#Shortened-external-product-1" title="Permalink"></a></h3><p><em>Paper:</em> Section 2.5.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.shortened_external_product"><code>shortened_external_product()</code></a></p><p>This is a version of the external product acting on a single polynomial <span>$a(x) \in R_{n,q}$</span> and a matrix of polynomials <span>$A \in R_{n,q}^{2\ell \times 2}$</span>:</p><div>\[\boldsymbol{a} \odot (A, B, \ell) = \left( a(x) \triangleleft (B, \ell) \right) A_{\ell+1 \dots 2\ell, \dots} \in R_{n,q}^2,\]</div><p>where <span>$A_{\ell+1 \dots 2\ell, \dots}$</span> denotes the bottom half of the matrix <span>$A$</span> (the rows from <span>$\ell+1$</span> to <span>$2\ell$</span>).</p><h2 id="Scheme-parameters-theory-1"><a class="docs-heading-anchor" href="#Scheme-parameters-theory-1">Scheme parameters</a><a class="docs-heading-anchor-permalink" href="#Scheme-parameters-theory-1" title="Permalink"></a></h2><p><em>Paper:</em> Section 4.1.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.Params"><code>Params</code></a></p><p>The constants introduced here will be used throughout the rest of the section.</p><p>The main parameter of the FHE scheme is the polynomial length <span>$n \ge 64$</span>, which must be a power of <span>$2$</span>.</p><p>Other parameters that need to be chosen:</p><ul><li>LWE modulus is set to <span>$r = 16n$</span> (it is possible to pick any <span>$r &gt;= 16n$</span> as long as <span>$r$</span> is divisible by <span>$8$</span>, which will require several minor adjustments in the algorithms; see the paper for details).</li><li>RLWE modulus <span>$q &gt;= nr$</span>. In this implementation we choose a prime <span>$q$</span> such that <span>$q-1$</span> is divisible by <span>$2n$</span> (to be able to multiply polynomials of length <span>$n$</span> using NTT).</li><li>Decomposition length <span>$\ell = 2$</span>. See <a href="theory.html#Flattening-1">Flattening</a> for details. Note that this value is &quot;hardcoded&quot; in the bootstrap modulus <span>$Q$</span> below (<span>$Q \le B^\ell$</span>), so it cannot be trivially adjusted.</li><li>Bootstrap modulus <span>$1220 r^4 n^2 \le Q \le 1225 r^4 n^2 = B^2$</span> (see below for the value of <span>$B$</span>). Again, we choose a prime <span>$Q$</span> such that <span>$Q-1$</span> is divisible by <span>$2m$</span> (to be able to multiply polynomials of length <span>$m$</span> using NTT).</li></ul><p>Dependent parameters:</p><ul><li>Extended polynomial length for bootstrapping <span>$m = r / 2$</span>.</li><li>Decomposition base <span>$B = 35 r^2 n$</span>. See <a href="theory.html#Flattening-1">Flattening</a> for details.</li><li>LWE error level <span>$D_r = r/4$</span>.</li><li>RLWE error level <span>$D_q = q \div 4$</span>.</li><li>Bootstrap error level <span>$\tilde{D}_Q = Q \div 8$</span>.</li><li>Lower limit for the bit size of LWE elements <span>$t = \lceil \log_2 r \rceil - 1$</span> (so <span>$2^t &lt; r \le 2^{t+1}$</span>).</li></ul><p>We will also need the gadget matrix <span>$G \in \mathbb{Z}_Q^{2\ell \times 2}$</span></p><div>\[G = \begin{bmatrix}
    1 &amp; 0 \\
    B &amp; 0 \\
    \dots &amp; 0 \\
    B^{\ell-1} &amp; 0 \\
    0 &amp; 1 \\
    0 &amp; B \\
    0 &amp; \dots \\
    0 &amp; B^{\ell-1} \\
\end{bmatrix}\]</div><h2 id="Private-key-generation-1"><a class="docs-heading-anchor" href="#Private-key-generation-1">Private key generation</a><a class="docs-heading-anchor-permalink" href="#Private-key-generation-1" title="Permalink"></a></h2><p><em>Paper:</em> Section 4.1.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.PrivateKey"><code>PrivateKey</code></a></p><p>A private key is simply a vector <span>$\boldsymbol{s} \in \{ 0, 1 \}^n$</span> with the elements <span>$s_i = \mathcal{U}(0, 1)$</span>, <span>$i \in [0, n-1]$</span>.</p><h2 id="Private-key-encryption-to-an-RLWE-1"><a class="docs-heading-anchor" href="#Private-key-encryption-to-an-RLWE-1">Private key encryption to an RLWE</a><a class="docs-heading-anchor-permalink" href="#Private-key-encryption-to-an-RLWE-1" title="Permalink"></a></h2><p><em>Paper:</em> Fig. 2.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.encrypt"><code>encrypt</code></a></p><p>Given:</p><ul><li>A private key <span>$\boldsymbol{s} \in \{ 0, 1 \}^n$</span>;</li><li>An <span>$n$</span>-bit message to encrypt <span>$\boldsymbol{m}  \in \{ 0, 1 \}^n$</span>.</li></ul><p>Algorithm:</p><ul><li>Generate <span>$\boldsymbol{u} \in \{ 0, 1 \}^n$</span>, <span>$u_i = \mathcal{U}(0, 1)$</span>.</li><li>Expand it into a random polynomial:<div>\[\boldsymbol{a} = \mathrm{Expand}[\boldsymbol{u}, t+1], \\
a(x) = \mathcal{P}[\boldsymbol{a}] \in R_{n,r}.\]</div></li><li>Generate<div>\[\boldsymbol{w} \in \mathbb{Z}_r^n: \ w_i = \mathcal{U}(-D_r \div 8, D_r \div 8) \,\mathrm{mod}\,r, \\
w(x) = \mathcal{P}[\boldsymbol{w}] \in R_{n,r}.\]</div></li><li>Calculate<div>\[b(x) = a(x) s(x) + w(x) + \mathcal{P}[\boldsymbol{m}] D_r \,\mathrm{mod}\,(x^n+1,r).\]</div></li><li>Leave only the highmost 5 bits of each coefficient of <span>$b(x)$</span> set:<div>\[b(x) = 2^{t-4} (b(x) \div 2^{t-4}).\]</div></li></ul><p>Result: an RLWE cipher <span>$(a(x),b(x)) \in R_{n,r}^2$</span>.</p><h3 id="Space-optimal-representation-private-1"><a class="docs-heading-anchor" href="#Space-optimal-representation-private-1">Space-optimal representation</a><a class="docs-heading-anchor-permalink" href="#Space-optimal-representation-private-1" title="Permalink"></a></h3><p><em>Paper:</em> Fig. 2.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.encrypt_optimal"><code>encrypt_optimal</code></a></p><p>Starting from where the algorithm in the previous section ended,</p><ul><li>Calculate <span>$\tilde{b}(x) = b(x) \div 2^{t-4}$</span> (remember, only highest 5 bits of each coefficient of <span>$b(x)$</span> are set).</li><li>Convert the vector <span>$\tilde{\boldsymbol{b}} = \mathcal{C}[\tilde{b}(x)]$</span> into a matrix <span>$V \in \{0, 1\}^{n \times 5}$</span> where the <span>$i$</span>-th row is the bit representation of <span>$\tilde{b}_i$</span>.</li></ul><p>Result: a pair <span>$(\boldsymbol{u}, V) \in \{0, 1\}^n \times \{0, 1\}^{n \times 5}$</span>.</p><h3 id="Restoring-from-the-space-optimal-representation-1"><a class="docs-heading-anchor" href="#Restoring-from-the-space-optimal-representation-1">Restoring from the space-optimal representation</a><a class="docs-heading-anchor-permalink" href="#Restoring-from-the-space-optimal-representation-1" title="Permalink"></a></h3><p><em>Paper:</em> Fig. 2.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.normalize_ciphertext"><code>normalize_ciphertext</code></a></p><p>Given a pair <span>$(\boldsymbol{u}, V) \in \{0, 1\}^n \times \{0, 1\}^{n \times 5}$</span>:</p><ul><li>Expand <span>$\boldsymbol{u}$</span> into a polynomial:<div>\[\boldsymbol{a} = \mathrm{Expand}[\boldsymbol{u}, t+1], \\
a(x) = \mathcal{P}[\boldsymbol{a}] \in R_{n,r}.\]</div></li><li>Convert <span>$V$</span> into a polynomial:<div>\[\tilde{\boldsymbol{b}} \in \mathbb{Z}_r^n: \ \tilde{b}_i = \sum_{j=0}^4 V_{ij} 2^j, \\
b(x) = 2^{t-4} \mathcal{P}[\tilde{\boldsymbol{b}}]\]</div></li></ul><p>Result: an RLWE cipher <span>$(a(x),b(x)) \in R_{n,r}^2$</span>.</p><h2 id="Public-key-generation-1"><a class="docs-heading-anchor" href="#Public-key-generation-1">Public key generation</a><a class="docs-heading-anchor-permalink" href="#Public-key-generation-1" title="Permalink"></a></h2><p><em>Paper:</em> Section 4.1.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.PrivateKey"><code>PrivateKey</code></a></p><p>Given a private key <span>$\boldsymbol{s} \in \{ 0, 1 \}^n$</span>:</p><ul><li>Generate<div>\[\boldsymbol{k}^{(0)} \in \mathbb{Z}_q^n:\ k^{(0)}_i = \mathcal{U}(0, q-1).\]</div></li><li>Generate<div>\[\boldsymbol{e} \in \mathbb{Z}_q^n:\ e_i = \mathcal{U}(-c, c),\]</div>where <span>$c$</span> is the largest integer such that <span>$c &lt; D_q / (41n)$</span>.</li><li>Calculate<div>\[k^{(1)}(x) = k^{(0)}(x) s(x) + e(x) \,\mathrm{mod}\,(x^n+1, q).\]</div></li></ul><p>Result: a pair <span>$(k^{(0)}(x), k^{(1)}(x)) \in R_{n,q}^2$</span>.</p><h2 id="Public-key-encryption-to-an-RLWE-1"><a class="docs-heading-anchor" href="#Public-key-encryption-to-an-RLWE-1">Public key encryption to an RLWE</a><a class="docs-heading-anchor-permalink" href="#Public-key-encryption-to-an-RLWE-1" title="Permalink"></a></h2><p><em>Paper:</em> Fig. 3.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.encrypt"><code>encrypt()</code></a></p><p>Given:</p><ul><li>A public key <span>$(k^{(0)}(x), k^{(1)}(x)) \in R_{n,q}^2$</span>;</li><li>A message to encrypt <span>$\boldsymbol{m} \in \{0, 1\}^n$</span>.</li></ul><p>Algorithm:</p><ul><li>Generate<div>\[\boldsymbol{u} \in \mathbb{Z}_q^n:\ \mathcal{C}[u(x)]_i = \mathcal{U}(-1, 1), \\
u(x) = \mathcal{P}[\boldsymbol{u}] \in R_{n,q}.\]</div></li><li>Generate<div>\[\boldsymbol{w}^{(1)} \in \mathbb{Z}_q^n:\ w^{(1)}_i = \mathcal{U}(-D_q/(41n), D_q/(41n)) \,\mathrm{mod}\,q, \\
w^{(1)}(x) = \mathcal{P}[\boldsymbol{w}^{(1)}] \in R_{n,q}.\]</div></li><li>Generate<div>\[\boldsymbol{w}^{(2)} \in \mathbb{Z}_q^n:\ \mathcal{U}(-D_q/82, D_q/82) \,\mathrm{mod}\,q, \\
w^{(2)}(x) = \mathcal{P}[\boldsymbol{w}^{(2)}] \in R_{n,q}.\]</div></li><li>Calculate<div>\[a_1(x) = k^{(0)}(x) u(x) + w^{(1)}(x) \,\mathrm{mod}\,(x^n+1, q), \\
b_1(x) = k^{(1)}(x) u(x) + w^{(2)}(x) + m(x) D_q \,\mathrm{mod}\,(x^n+1, q).\]</div></li><li>Calculate<div>\[a(x) = \mathrm{ModRed}[a_1(x), q, r], \\
b(x) = 2^{t-5} \mathrm{ModRed}[b_1(x), q, r \div 2^{t-5}, \mathrm{floor}].\]</div>(only highmost 6 bits of each coefficient of <span>$b(x)$</span> are set).</li></ul><p>Result: an RLWE cipher <span>$(a(x),b(x)) \in R_{n,r}^2$</span>.</p><h3 id="Space-optimal-representation-1"><a class="docs-heading-anchor" href="#Space-optimal-representation-1">Space-optimal representation</a><a class="docs-heading-anchor-permalink" href="#Space-optimal-representation-1" title="Permalink"></a></h3><p><em>Paper:</em> Fig. 3.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.encrypt_optimal"><code>encrypt_optimal()</code></a></p><p>Starting from where the algorithm in the previous section ended,</p><ul><li>Calculate <span>$\tilde{b}(x) = b(x) \div 2^{t-5}$</span> (remember, only highmost 6 bits of each coefficient of <span>$b(x)$</span> are set).</li><li>Convert the vector <span>$\tilde{\boldsymbol{b}} = \mathcal{C}[\tilde{b}(x)]$</span> into a matrix <span>$V \in \{0, 1\}^{n \times 6}$</span> where the <span>$i$</span>-th row is the bit representation of <span>$\tilde{b}_i$</span>.</li><li>Convert the vector <span>$\boldsymbol{a} = \mathcal{C}[a(x)]$</span> into a matrix <span>$U \in \{0, 1\}^{n \times (t+1)}$</span> where the <span>$i$</span>-th row is the bit representation of <span>$a_i$</span>.</li></ul><p>Result: a pair <span>$(U, V) \in \{0, 1\}^{n \times (t+1)} \times \{0, 1\}^{n \times 6}$</span>.</p><h3 id="Restoring-from-the-space-optimal-representation-2"><a class="docs-heading-anchor" href="#Restoring-from-the-space-optimal-representation-2">Restoring from the space-optimal representation</a><a class="docs-heading-anchor-permalink" href="#Restoring-from-the-space-optimal-representation-2" title="Permalink"></a></h3><p><em>Paper:</em> Fig. 3.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.normalize_ciphertext"><code>normalize_ciphertext()</code></a></p><p>Given a pair <span>$(U, V) \in \{0, 1\}^{n \times (t+1)} \times \{0, 1\}^{n \times 6}$</span>:</p><ul><li>Convert <span>$U$</span> into a polynomial:<div>\[\boldsymbol{a} \in \mathbb{Z}_r^n:\ a_i = \sum_{j=0}^t U_{ij} 2^j, \\
a(x) = \mathcal{P}[\boldsymbol{a}] \in R_{n,r}.\]</div></li><li>Convert <span>$V$</span> into a polynomial:<div>\[\tilde{\boldsymbol{b}} \in \mathbb{Z}_r^n:\ \tilde{b}_i = \sum_{j=0}^t V_{ij} 2^j, \\
b(x) = 2^{t-5} \mathcal{P}[\tilde{\boldsymbol{a}}] \in R_{n,r}.\]</div></li></ul><p>Result: an RLWE cipher <span>$(a(x),b(x)) \in R_{n,r}^2$</span>.</p><h2 id="Creating-LWEs-1"><a class="docs-heading-anchor" href="#Creating-LWEs-1">Creating LWEs</a><a class="docs-heading-anchor-permalink" href="#Creating-LWEs-1" title="Permalink"></a></h2><h3 id="Private-key-encryption-to-an-LWE-1"><a class="docs-heading-anchor" href="#Private-key-encryption-to-an-LWE-1">Private key encryption to an LWE</a><a class="docs-heading-anchor-permalink" href="#Private-key-encryption-to-an-LWE-1" title="Permalink"></a></h3><p><em>Note:</em> this is not explicitly described in the paper, but Lemma 2.3 sets the maximum error one can introduce during encryption.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.encrypt"><code>encrypt()</code></a></p><p>Given:</p><ul><li>a message to encrypt <span>$y \in \{0, 1\}$</span>;</li><li>a secret key <span>$\boldsymbol{s} \in \{0, 1\}^n$</span>.</li></ul><p>Algorithm:</p><ul><li>Generate a vector <span>$\boldsymbol{a}^\prime \in \mathbb{Z}_q^n$</span> with the elements <span>$a^\prime_i = \mathcal{U}(0, q-1)$</span>.</li><li>Generate <span>$e = \mathcal{U}(-\tau, \tau) \,\mathrm{mod}\, q$</span> where <span>$\tau = (q (n-3)) \div (2r)$</span>.</li><li>Calculate<div>\[b^\prime = \boldsymbol{a} \cdot \boldsymbol{s} + e + y D_q \,\mathrm{mod}\, q.\]</div></li><li>Modulus reduction:<div>\[\boldsymbol{a} = \mathrm{ModRed}[\boldsymbol{a}^\prime, q, r], \\
b = \mathrm{ModRed}[b^\prime, q, r].\]</div></li></ul><p>Result: an LWE cipher <span>$\mathrm{LWE}_{\boldsymbol{s}}(y) = (\boldsymbol{a}, b) \in \mathbb{Z}_r^n \times \mathbb{Z}_r$</span>.</p><h3 id="Extracting-an-LWE-from-a-packed-RLWE-1"><a class="docs-heading-anchor" href="#Extracting-an-LWE-from-a-packed-RLWE-1">Extracting an LWE from a packed RLWE</a><a class="docs-heading-anchor-permalink" href="#Extracting-an-LWE-from-a-packed-RLWE-1" title="Permalink"></a></h3><p><em>Paper:</em> Section 4.5.1.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.split_ciphertext"><code>split_ciphertext()</code></a></p><p>Given an RLWE cipher <span>$\mathrm{RLWE}_{\boldsymbol{s}}(\boldsymbol{y}) = (a(x), b(x)) \in R_{n,r}^2$</span> encrypting an <span>$n$</span>-bit message <span>$\boldsymbol{y} \in \{0, 1\}^n$</span>, the LWE <span>$\mathrm{LWE}_{\boldsymbol{s}}(y_i)$</span> encrpyting the <span>$i$</span>-th bit is</p><div>\[\mathrm{LWE}_{\boldsymbol{s}}(y_i) = (\mathrm{Extract}[\mathcal{C}[a(x)], i, n], \mathcal{C}[b(x)]_i).\]</div><h3 id="Extracting-an-LWE-from-a-RLWE-1"><a class="docs-heading-anchor" href="#Extracting-an-LWE-from-a-RLWE-1">Extracting an LWE from a RLWE</a><a class="docs-heading-anchor-permalink" href="#Extracting-an-LWE-from-a-RLWE-1" title="Permalink"></a></h3><p><em>Note:</em> this is not described in the original paper.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.split_ciphertext"><code>split_ciphertext()</code></a></p><p>The procedure is the same as for the packed RLWE. Given an RLWE cipher <span>$\mathrm{RLWE}_{\boldsymbol{s}}(\boldsymbol{y}) = (a(x), b(x)) \in R_{m,r}^2$</span> encrypting an <span>$n$</span>-bit message <span>$\boldsymbol{y} \in \{0, 1\}^n$</span>, the LWE <span>$\mathrm{LWE}_{\boldsymbol{s}}(y_i)$</span> encrpyting the <span>$i$</span>-th bit is</p><div>\[\mathrm{LWE}_{\boldsymbol{s}}(y_i) = (\mathrm{Extract}[\mathcal{C}[a(x)], i, n], \mathcal{C}[b(x)]_i).\]</div><h2 id="Decryption-1"><a class="docs-heading-anchor" href="#Decryption-1">Decryption</a><a class="docs-heading-anchor-permalink" href="#Decryption-1" title="Permalink"></a></h2><h3 id="Decrypting-an-LWE-1"><a class="docs-heading-anchor" href="#Decrypting-an-LWE-1">Decrypting an LWE</a><a class="docs-heading-anchor-permalink" href="#Decrypting-an-LWE-1" title="Permalink"></a></h3><p><em>Paper:</em> Section 2.3.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.decrypt"><code>decrypt()</code></a></p><p>Given:</p><ul><li>An LWE cipher encrypting <span>$y \in \{0,1\}$</span> <span>$\mathrm{LWE}_{\boldsymbol{s}}(y) = (\boldsymbol{a}, b) \in \mathbb{Z}_r^n \times \mathbb{Z}_r$</span>;</li><li>A secret key <span>$\boldsymbol{s} \in \{0, 1\}^n$</span>.</li></ul><p>Algorithm:</p><ul><li>Calculate<div>\[b_1 = b - \boldsymbol{a} \cdot \boldsymbol{s} + D_r / 2 \,\mathrm{mod}\,r.\]</div></li><li>Calculate <span>$y = b_1 \div D_r$</span>.</li></ul><p>The addition of <span>$D_r / 2$</span> as compared to the algorithm provided in the paper allows us to use <span>$\div$</span> (that is, the regular integer floor division by <span>$D_r$</span>) as compared to <span>$\lfloor \rceil$</span> in the paper.</p><h3 id="Decrypting-a-packed-RLWE-1"><a class="docs-heading-anchor" href="#Decrypting-a-packed-RLWE-1">Decrypting a packed RLWE</a><a class="docs-heading-anchor-permalink" href="#Decrypting-a-packed-RLWE-1" title="Permalink"></a></h3><p><em>Paper:</em> Section 4.2.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.decrypt"><code>decrypt()</code></a></p><p>Given:</p><ul><li>An RLWE cipher encrypting <span>$\boldsymbol{y} \in \{0,1\}^n$</span> <span>$\mathrm{RLWE}_{\boldsymbol{s}}(\boldsymbol{y}) = (a(x), b(x)) \in R_{n,r}^2$</span>;</li><li>A secret key <span>$\boldsymbol{s} \in \{0, 1\}^n$</span>.</li></ul><p>Algorithm:</p><ul><li>Calculate<div>\[b_1(x) = b(x) - a(x) s(x) \,\mathrm{mod}\,(x^n+1, r).\]</div></li><li>Calculate<div>\[y_i = (\mathcal{C}[b_1(x)]_i + D_r / 2 \,\mathrm{mod}\,r) \div D_r,
\quad i = 0, \dots, n-1.\]</div></li></ul><p>Again, the shift by <span>$D_r / 2$</span> allows us to use the floor division instead of rounding division.</p><h3 id="Decrypting-an-RLWE-1"><a class="docs-heading-anchor" href="#Decrypting-an-RLWE-1">Decrypting an RLWE</a><a class="docs-heading-anchor-permalink" href="#Decrypting-an-RLWE-1" title="Permalink"></a></h3><p><em>Note:</em> this algorithm is not given in the original paper.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.decrypt"><code>decrypt()</code></a></p><p>The algorithm is almost identical to the one for a packed RLWE, with the only change being the polynomial modulus in the first step.</p><p>Given:</p><ul><li>An RLWE cipher encrypting <span>$\boldsymbol{y} \in \{0,1\}^n$</span> <span>$\mathrm{RLWE}_{\boldsymbol{s}}(\boldsymbol{y}) = (a(x), b(x)) \in R_{m,r}^2$</span>;</li><li>A secret key <span>$\boldsymbol{s} \in \{0, 1\}^n$</span>.</li></ul><p>Algorithm:</p><ul><li>Calculate<div>\[b_1(x) = b(x) - a(x) s(x) \,\mathrm{mod}\,(x^m+1, r).\]</div></li><li>Calculate<div>\[y_i = (\mathcal{C}[b_1(x)]_i + D_r / 2 \,\mathrm{mod}\,r) \div D_r,
\quad i = 0, \dots, n-1.\]</div></li></ul><h2 id="Bootstrap-key-generation-1"><a class="docs-heading-anchor" href="#Bootstrap-key-generation-1">Bootstrap key generation</a><a class="docs-heading-anchor-permalink" href="#Bootstrap-key-generation-1" title="Permalink"></a></h2><p><em>Paper:</em> Section 4.1.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.BootstrapKey"><code>BootstrapKey</code></a></p><p>Given a secret key <span>$\boldsymbol{s} \in \{0, 1\}^n$</span>, for each <span>$i = 0, \dots, n-1$</span>:</p><ul><li>Generate a matrix of polynomials <span>$A \in R_{m,Q}^{2\ell \times n}$</span> where<div>\[\mathcal{C}[A_{ji}(x)]_k = \mathcal{U}(0, Q-1), \quad k = 0, \dots, n-1.\]</div></li><li>Generate a matrix of polynomials <span>$E \in R_{m,Q}^{2\ell \times n}$</span> where<div>\[\mathcal{C}[E_{ji}(x)]_k = \mathcal{U}(-n, n) \,\mathrm{mod}\,Q, \quad k = 0, \dots, n-1.\]</div></li><li>Calculate<div>\[B(x) = A(x) \mathcal{P}[\boldsymbol{s}](x) + E(x) \,\mathrm{mod}\,(x^m+1, Q).\]</div></li><li>For <span>$i = 0, \dots, n-1$</span>, calculate<div>\[C^{(i)} = \begin{bmatrix}
    A_{1i}(x) &amp; B_{1i}(x) \\
    A_{2i}(x) &amp; B_{2i}(x) \\
    A_{3i}(x) &amp; B_{3i}(x) \\
    A_{4i}(x) &amp; B_{4i}(x)
\end{bmatrix} + s_i G \,\mathrm{mod}\,Q.\]</div>where <span>$G$</span> is the gadget matrix (see <a href="theory.html#Scheme-parameters-theory-1">Scheme parameters</a>).</li></ul><p>The resulting bootstrap key is a list of <span>$n$</span> matrices of polynomials <span>$C^{(i)} \in R_{m,Q}^{2\ell \times n}$</span>.</p><h2 id="Bootstrap-theory-1"><a class="docs-heading-anchor" href="#Bootstrap-theory-1">Bootstrap</a><a class="docs-heading-anchor-permalink" href="#Bootstrap-theory-1" title="Permalink"></a></h2><p><em>Paper:</em> Fig. 1.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.bootstrap"><code>bootstrap()</code></a></p><p>Given:</p><ul><li>A bootstrap key –- a list of <span>$n$</span> matrices of polynomials <span>$C^{(i)} \in R_{m,Q}^{2\ell \times n}$</span>;</li><li>Two LWE ciphers <span>$\boldsymbol{v}_1 = \mathrm{LWE}_{\boldsymbol{s}}(y_1)$</span>, <span>$\boldsymbol{v}_2 = \mathrm{LWE}_{\boldsymbol{s}}(y_2)$</span>, where <span>$\boldsymbol{v}_1, \boldsymbol{v}_2 \in \mathbb{Z}^n_r \times \mathbb{Z}_r$</span>.</li></ul><p>Algorithm:</p><ul><li>Sum both LWE ciphers element-wise:<div>\[\boldsymbol{u} = \boldsymbol{v}_1 + \boldsymbol{v}_2 = (u_0, \dots, u_{n-1}, u_n) \in \mathbb{Z}^n_r \times \mathbb{Z}_r.\]</div></li><li>Build<div>\[t(x) = \sum_{j=-D_r+1}^{D_r-1} x^j \,\mathrm{mod}\,(x^m+1, Q).\]</div>See <a href="theory.html#Negative-powers-in-polynomials-1">Negative powers in polynomials</a> for the explanation of how the modulus is taken.</li><li>Initilize <span>$a(x), b(x) \in R_{m,Q}$</span><div>\[a(x) = 0, \\
b(x) = t(x) x^{-u_n} \tilde{D}_Q \,\mathrm{mod}\,(x^m+1, Q).\]</div></li><li>For <span>$i = 0 \dots n-1$</span>:<div>\[A^{(i)} = G + (x^{u_i} - 1) C^{(i)} \,\mathrm{mod}\,(x^m+1, Q), \\
(a(x), b(x)) \leftarrow (a(x), b(x)) \odot (A^{(i)}, B, \ell),\]</div>where G is the gadget matrix (see <a href="theory.html#Scheme-parameters-theory-1">Scheme parameters</a>) and <span>$\odot$</span> is the <a href="theory.html#External-product-1">external product</a>.</li><li>Build LWEs<div>\[\boldsymbol{a}^{\mathrm{AND}} = (\mathrm{Extract}[\boldsymbol{a}, 3m/4], \tilde{D}_Q + b_{3m/4}), \\
\boldsymbol{a}^{\mathrm{OR}} = (-\mathrm{Extract}[\boldsymbol{a}, 3m/4], \tilde{D}_Q - b_{m/4}), \\
\boldsymbol{a}^{\mathrm{XOR}} = \boldsymbol{a}_{\mathrm{OR}} - \boldsymbol{a}_{\mathrm{AND}}.\]</div>where<div>\[\boldsymbol{a} = \mathcal{C}[a(x)] \in \mathbb{Z}_Q^m, \\
\boldsymbol{b} = \mathcal{C}[b(x)] \in \mathbb{Z}_Q^m.\]</div></li><li>Modulus reduction:<div>\[\boldsymbol{c}^{\mathrm{AND}} = \mathrm{ModRed}[\boldsymbol{a}^{\mathrm{AND}}, Q, r], \\
\boldsymbol{c}^{\mathrm{OR}} = \mathrm{ModRed}[\boldsymbol{a}^{\mathrm{OR}}, Q, r], \\
\boldsymbol{c}^{\mathrm{XOR}} = \mathrm{ModRed}[\boldsymbol{a}^{\mathrm{XOR}}, Q, r].\]</div>Here <span>$\boldsymbol{c}^{\mathrm{AND}}, \boldsymbol{c}^{\mathrm{OR}}, \boldsymbol{c}^{\mathrm{XOR}} \in \mathbb{Z}_r^n \times \mathbb{Z}_r$</span>.</li></ul><p>Result: LWE ciphers of <span>$y_1 \wedge y_2$</span> (AND), <span>$y_1 \vee y_2$</span> (OR) and <span>$y_1 \oplus y_2$</span> (XOR):</p><div>\[\boldsymbol{c}^{\mathrm{AND}} = \mathrm{LWE}_{\boldsymbol{s}}(y_1 \wedge y_2), \\
\boldsymbol{c}^{\mathrm{OR}} = \mathrm{LWE}_{\boldsymbol{s}}(y_1 \vee y_2), \\
\boldsymbol{c}^{\mathrm{XOR}} = \mathrm{LWE}_{\boldsymbol{s}}(y_1 \oplus y_2).\]</div><p>One can use either the deterministic or the random version of the external product <span>$\odot$</span>, depending on the desired behavior of the bootstrap.</p><h2 id="Packing-LWEs-1"><a class="docs-heading-anchor" href="#Packing-LWEs-1">Packing LWEs</a><a class="docs-heading-anchor-permalink" href="#Packing-LWEs-1" title="Permalink"></a></h2><p><em>Paper:</em> Lemma 4.3.</p><p><em>Implementation:</em> <a href="api.html#SGFHE.pack_encrypted_bits"><code>pack_encrypted_bits()</code></a></p><p>Given:</p><ul><li><span>$n$</span> LWE ciphers <span>$\boldsymbol{z}^{(i)} = \mathrm{LWE}_{\boldsymbol{s}}(y_i) \in \mathbb{Z}_r^n \times \mathbb{Z}_r, i = 0, \dots, n-1$</span>;</li><li>a bootstrap key <span>$\{C^{(i)}\}, i = 0, \dots, n-1$</span>.</li></ul><p>Algorithm:</p><ul><li>Create a trivial LWE cipher encrypting <span>$1$</span>: <span>$\mathrm{LWE}_{\boldsymbol{s}}(1) = (\boldsymbol{0}, D_r) \in \mathbb{Z}_r^n \times \mathbb{Z}_r$</span>.</li><li>For <span>$i = 0, \dots, n-1$</span> apply the <a href="api.html#Bootstrap-1">Bootstrap</a> algorithm to the pair <span>$E_{\boldsymbol{s}}(1)$</span> and <span>$\boldsymbol{z}^{(i)}$</span> up to and not including the modulus reduction step, leaving only the first result (corresponding to the AND gate). This will produce <span>$n$</span> LWEs:<div>\[\boldsymbol{a}^{\mathrm{AND},(i)}
\equiv (\boldsymbol{a}^{(i)}, b^{(i)})
\in \mathbb{Z}_Q^n \times \mathbb{Z}_Q.\]</div></li><li>For <span>$i = 0, \dots, n-1$</span>, build polynomials<div>\[\tilde{a}^{(i)}(x) = \mathcal{P}[\tilde{\boldsymbol{a}}^{(i)}] \in R_{m,Q},\]</div>where <span>$\tilde{a}^{(i)}_j = a^{(j)}_i$</span>, <span>$j = 0, \dots, n-1$</span>. Note that we are treating the resulting polynomials as modulo <span>$(x^m+1)$</span> despite them only having powers of <span>$x$</span> up to <span>$n-1$</span>.</li><li>Create a polynomial <span>$\tilde{b}(x) = \mathcal{P}[\boldsymbol{b}] \in R_{m,Q}$</span>. Again, we are treating the resulting polynomial as modulo <span>$(x^m+1)$</span>.</li><li>Calculate:<div>\[\left( \tilde{w}(x), \tilde{v}(x) \right) = \sum_{i=0}^{n-1}
  a^{(i)}(x) \odot (C^{(i)}, B, \ell),\]</div>where <span>$\odot$</span> is the <a href="theory.html#Shortened-external-product-1">shortened external product</a>.</li><li>Calculate:<div>\[\tilde{w}_1(x) = -\tilde{w}(x), \\
\tilde{v}_1(x) = b(x) - \tilde{v}(x).\]</div></li><li>Modulus reduction:<div>\[w(x) = \mathrm{ModRed}[\tilde{w}_1(x), Q, r], \\
v(x) = \mathrm{ModRed}[\tilde{v}_1(x), Q, r].\]</div></li></ul><p>Result: an RLWE cipher <span>$(w(x), v(x)) \in R_{m,r}^2$</span> encrypting the vector <span>$\boldsymbol{y}$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="api.html">« API reference</a><a class="docs-footer-nextpage" href="history.html">Version history »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 20 December 2019 18:40">Friday 20 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
